Index: renderer/Cinematic.cpp
--- renderer/Cinematic.cpp.orig
+++ renderer/Cinematic.cpp
@@ -39,7 +39,6 @@ If you have questions concerning this license or the a
 
 extern idCVar s_noSound;
 
-#define JPEG_INTERNALS
 //extern "C" {
 #include <jpeglib.h>
 //}
@@ -619,6 +618,7 @@ bool idCinematicLocal::InitFromFFMPEGFile( const char*
 	int ret;
 	int ret2;
 	int file_size;
+	char error[64];
 	looping = amilooping;
 	startTime = 0;
 	isRoQ = false;
@@ -688,8 +688,7 @@ bool idCinematicLocal::InitFromFFMPEGFile( const char*
 	dec_ctx = avcodec_alloc_context3( dec );
 	if( ( ret = avcodec_parameters_to_context( dec_ctx, fmt_ctx->streams[video_stream_index]->codecpar ) ) < 0 )
 	{
-		char* error = new char[256];
-		av_strerror( ret, error, 256 );
+		av_strerror( ret, error, sizeof( error ) );
 		common->Warning( "idCinematic: Failed to create video codec context from codec parameters with error: %s\n", error );
 	}
 	dec_ctx->time_base = fmt_ctx->streams[video_stream_index]->time_base;
@@ -698,8 +697,7 @@ bool idCinematicLocal::InitFromFFMPEGFile( const char*
 	/* init the video decoder */
 	if( ( ret = avcodec_open2( dec_ctx, dec, NULL ) ) < 0 )
 	{
-		char* error = new char[256];
-		av_strerror( ret, error, 256 );
+		av_strerror( ret, error, sizeof( error ) );
 		common->Warning( "idCinematic: Cannot open video decoder for: '%s', %d, with error: %s\n", qpath, looping, error );
 		return false;
 	}
@@ -712,8 +710,7 @@ bool idCinematicLocal::InitFromFFMPEGFile( const char*
 		dec_ctx2 = avcodec_alloc_context3( dec2 );
 		if( ( ret2 = avcodec_parameters_to_context( dec_ctx2, fmt_ctx->streams[audio_stream_index]->codecpar ) ) < 0 )
 		{
-			char* error = new char[256];
-			av_strerror( ret2, error, 256 );
+			av_strerror( ret2, error, sizeof( error ) );
 			common->Warning( "idCinematic: Failed to create audio codec context from codec parameters with error: %s\n", error );
 		}
 		dec_ctx2->time_base = fmt_ctx->streams[audio_stream_index]->time_base;
@@ -727,8 +724,12 @@ bool idCinematicLocal::InitFromFFMPEGFile( const char*
 		if( dec_ctx2->sample_fmt >= AV_SAMPLE_FMT_U8P )											// SRS - Planar formats start at AV_SAMPLE_FMT_U8P
 		{
 			dst_smp = static_cast<AVSampleFormat>( dec_ctx2->sample_fmt - AV_SAMPLE_FMT_U8P );	// SRS - Setup context to convert from planar to packed
-			swr_ctx = swr_alloc_set_opts( NULL, dec_ctx2->channel_layout, dst_smp, dec_ctx2->sample_rate, dec_ctx2->channel_layout, dec_ctx2->sample_fmt, dec_ctx2->sample_rate, 0, NULL );
-			int res = swr_init( swr_ctx );
+			if( ( ret2 = swr_alloc_set_opts2( &swr_ctx, &dec_ctx2->ch_layout, dst_smp, dec_ctx2->sample_rate, &dec_ctx2->ch_layout, dec_ctx2->sample_fmt, dec_ctx2->sample_rate, 0, NULL ) ) < 0 )
+			{
+				av_strerror( ret2, error, sizeof( error ) );
+				common->Warning( "idCinematic: Failed to create audio resample context with error: %s\n", error );
+			}
+			ret2 = swr_init( swr_ctx );
 			hasplanar = true;
 		}
 		else
@@ -736,7 +737,7 @@ bool idCinematicLocal::InitFromFFMPEGFile( const char*
 			dst_smp = dec_ctx2->sample_fmt;														// SRS - Must always define the destination format
 			hasplanar = false;
 		}
-		common->Printf( "Cinematic audio stream found: Sample Rate=%d Hz, Channels=%d, Format=%s, Planar=%d\n", dec_ctx2->sample_rate, dec_ctx2->channels, GetSampleFormat( dec_ctx2->sample_fmt ), hasplanar );
+		common->Printf( "Cinematic audio stream found: Sample Rate=%d Hz, Channels=%d, Format=%s, Planar=%d\n", dec_ctx2->sample_rate, dec_ctx2->ch_layout.nb_channels, GetSampleFormat( dec_ctx2->sample_fmt ), hasplanar );
 		cinematicAudio->InitAudio( dec_ctx2 );
 	}
 	else
@@ -1310,6 +1311,7 @@ idCinematicLocal::ImageForTimeFFMPEG
 cinData_t idCinematicLocal::ImageForTimeFFMPEG( int thisTime )
 {
 	cinData_t	cinData;
+	char		error[64];
 	uint8_t*	audioBuffer = NULL;
 	int			num_bytes = 0;
 
@@ -1404,16 +1406,14 @@ cinData_t idCinematicLocal::ImageForTimeFFMPEG( int th
 				// Decode video frame
 				if( ( res = avcodec_send_packet( dec_ctx, &packet ) ) != 0 )
 				{
-					char* error = new char[256];
-					av_strerror( res, error, 256 );
+					av_strerror( res, error, sizeof( error ) );
 					common->Warning( "idCinematic: Failed to send video packet for decoding with error: %s\n", error );
 				}
 				else
 				{
 					if( ( frameFinished = avcodec_receive_frame( dec_ctx, frame ) ) != 0 )
 					{
-						char* error = new char[256];
-						av_strerror( frameFinished, error, 256 );
+						av_strerror( frameFinished, error, sizeof( error ) );
 						common->Warning( "idCinematic: Failed to receive video frame from decoding with error: %s\n", error );
 					}
 				}
@@ -1424,22 +1424,20 @@ cinData_t idCinematicLocal::ImageForTimeFFMPEG( int th
 				res = avcodec_send_packet( dec_ctx2, &packet );
 				if( res != 0 && res != AVERROR( EAGAIN ) )
 				{
-					char* error = new char[256];
-					av_strerror( res, error, 256 );
+					av_strerror( res, error, sizeof( error ) );
 					common->Warning( "idCinematic: Failed to send audio packet for decoding with error: %s\n", error );
 				}
 				else
 				{
 					if( ( frameFinished1 = avcodec_receive_frame( dec_ctx2, frame3 ) ) != 0 )
 					{
-						char* error = new char[256];
-						av_strerror( frameFinished1, error, 256 );
+						av_strerror( frameFinished1, error, sizeof( error ) );
 						common->Warning( "idCinematic: Failed to receive audio frame from decoding with error: %s\n", error );
 					}
 					else
 					{
 						// SRS - Since destination sample format is packed (non-planar), returned bufflinesize equals num_bytes
-						res = av_samples_alloc( &audioBuffer, &num_bytes, frame3->channels, frame3->nb_samples, dst_smp, 0 );
+						res = av_samples_alloc( &audioBuffer, &num_bytes, frame3->ch_layout.nb_channels, frame3->nb_samples, dst_smp, 0 );
 						if( res < 0 || res != num_bytes )
 						{
 							common->Warning( "idCinematic: Failed to allocate audio buffer with result: %d\n", res );
