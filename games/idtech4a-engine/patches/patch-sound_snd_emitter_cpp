Index: sound/snd_emitter.cpp
--- sound/snd_emitter.cpp.orig
+++ sound/snd_emitter.cpp
@@ -4,7 +4,7 @@
 Doom 3 GPL Source Code
 Copyright (C) 1999-2011 id Software LLC, a ZeniMax Media company.
 
-This file is part of the Doom 3 GPL Source Code (?Doom 3 Source Code?).
+This file is part of the Doom 3 GPL Source Code ("Doom 3 Source Code").
 
 Doom 3 Source Code is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -37,8 +37,7 @@ If you have questions concerning this license or the a
 idSoundFade::Clear
 ===================
 */
-void idSoundFade::Clear()
-{
+void idSoundFade::Clear() {
 	fadeStart44kHz = 0;
 	fadeEnd44kHz = 0;
 	fadeStartVolume = 0;
@@ -50,20 +49,18 @@ void idSoundFade::Clear()
 idSoundFade::FadeDbAt44kHz
 ===================
 */
-float idSoundFade::FadeDbAt44kHz(int current44kHz)
-{
+float idSoundFade::FadeDbAt44kHz( int current44kHz ) {
 	float	fadeDb;
 
-	if (current44kHz >= fadeEnd44kHz) {
+	if ( current44kHz >= fadeEnd44kHz ) {
 		fadeDb = fadeEndVolume;
-	} else if (current44kHz > fadeStart44kHz) {
-		float fraction = (fadeEnd44kHz - fadeStart44kHz);
-		float over = (current44kHz - fadeStart44kHz);
-		fadeDb = fadeStartVolume + (fadeEndVolume - fadeStartVolume) * over / fraction;
+	} else if ( current44kHz > fadeStart44kHz ) {
+		float fraction = ( fadeEnd44kHz - fadeStart44kHz );
+		float over = ( current44kHz - fadeStart44kHz );
+		fadeDb = fadeStartVolume + ( fadeEndVolume - fadeStartVolume ) * over / fraction;
 	} else {
 		fadeDb = fadeStartVolume;
 	}
-
 	return fadeDb;
 }
 
@@ -87,12 +84,10 @@ permute 4 = 201
 permute 5 = 210
 =======================
 */
-void PermuteList_r(int *list, int listLength, int permute, int maxPermute)
-{
-	if (listLength < 2) {
+void PermuteList_r( int *list, int listLength, int permute, int maxPermute ) {
+	if ( listLength < 2 ) {
 		return;
 	}
-
 	permute %= maxPermute;
 	int	swap = permute * listLength / maxPermute;
 	int	old = list[swap];
@@ -100,57 +95,49 @@ void PermuteList_r(int *list, int listLength, int perm
 	list[0] = old;
 
 	maxPermute /= listLength;
-	PermuteList_r(list + 1, listLength - 1, permute, maxPermute);
+	PermuteList_r( list + 1, listLength - 1, permute, maxPermute );
 }
 
-int	Factorial(int val)
-{
+int	Factorial( int val ) {
 	int	fact = val;
-
-	while (val > 1) {
+	while ( val > 1 ) {
 		val--;
 		fact *= val;
 	}
-
 	return fact;
 }
 
-void GeneratePermutedList(int *list, int listLength, int permute)
-{
-	for (int i = 0 ; i < listLength ; i++) {
+void GeneratePermutedList( int *list, int listLength, int permute ) {
+	for ( int i = 0 ; i < listLength ; i++ ) {
 		list[i] = i;
 	}
 
 	// we can't calculate > 12 factorial, so we can't easily build a permuted list
-	if (listLength > 12) {
+	if ( listLength > 12 ) {
 		return;
 	}
 
 	// calculate listLength factorial
-	int		maxPermute = Factorial(listLength);
+	int		maxPermute = Factorial( listLength );
 
 	// recursively permute
-	PermuteList_r(list, listLength, permute, maxPermute);
+	PermuteList_r( list, listLength, permute, maxPermute );
 }
 
-void TestPermutations(void)
-{
+void TestPermutations( void ) {
 	int	list[SOUND_MAX_LIST_WAVS];
 
-	for (int len = 1 ; len < 5 ; len++) {
-		common->Printf("list length: %i\n", len);
+	for ( int len = 1 ; len < 5 ; len++ ) {
+		common->Printf( "list length: %i\n", len );
 
-		int	max = Factorial(len);
-
-		for (int j = 0 ; j < max * 2 ; j++) {
-			GeneratePermutedList(list, len, j);
-			common->Printf("%4i : ", j);
-
-			for (int k = 0 ; k < len ; k++) {
-				common->Printf("%i", list[k]);
+		int	max = Factorial( len );
+		for ( int j = 0 ; j < max * 2 ; j++ ) {
+			GeneratePermutedList( list, len, j );
+			common->Printf( "%4i : ", j );
+			for ( int k = 0 ; k < len ; k++ ) {
+				common->Printf( "%i", list[k] );
 			}
-
-			common->Printf("\n");
+			common->Printf( "\n" );
 		}
 	}
 }
@@ -162,8 +149,7 @@ void TestPermutations(void)
 idSoundChannel::idSoundChannel
 ===================
 */
-idSoundChannel::idSoundChannel(void)
-{
+idSoundChannel::idSoundChannel( void ) {
 	decoder = NULL;
 	Clear();
 }
@@ -173,8 +159,7 @@ idSoundChannel::idSoundChannel(void)
 idSoundChannel::~idSoundChannel
 ===================
 */
-idSoundChannel::~idSoundChannel(void)
-{
+idSoundChannel::~idSoundChannel( void ) {
 	Clear();
 }
 
@@ -183,8 +168,7 @@ idSoundChannel::~idSoundChannel(void)
 idSoundChannel::Clear
 ===================
 */
-void idSoundChannel::Clear(void)
-{
+void idSoundChannel::Clear( void ) {
 	int j;
 
 	Stop();
@@ -195,12 +179,10 @@ void idSoundChannel::Clear(void)
 	diversity = 0.0f;
 	leadinSample = NULL;
 	trigger44kHzTime = 0;
-
-	for (j = 0; j < 6; j++) {
+	for( j = 0; j < 6; j++ ) {
 		lastV[j] = 0.0f;
 	}
-
-	memset(&parms, 0, sizeof(parms));
+	memset( &parms, 0, sizeof(parms) );
 #ifdef _HUMANHEAD
 	parms.subIndex = -1;
 #endif
@@ -217,11 +199,9 @@ void idSoundChannel::Clear(void)
 idSoundChannel::Start
 ===================
 */
-void idSoundChannel::Start(void)
-{
+void idSoundChannel::Start( void ) {
 	triggerState = true;
-
-	if (decoder == NULL) {
+	if ( decoder == NULL ) {
 		decoder = idSampleDecoder::Alloc();
 	}
 }
@@ -231,12 +211,10 @@ void idSoundChannel::Start(void)
 idSoundChannel::Stop
 ===================
 */
-void idSoundChannel::Stop(void)
-{
+void idSoundChannel::Stop( void ) {
 	triggerState = false;
-
-	if (decoder != NULL) {
-		idSampleDecoder::Free(decoder);
+	if ( decoder != NULL ) {
+		idSampleDecoder::Free( decoder );
 		decoder = NULL;
 	}
 }
@@ -246,41 +224,28 @@ void idSoundChannel::Stop(void)
 idSoundChannel::ALStop
 ===================
 */
-void idSoundChannel::ALStop(void)
-{
-#ifdef _OPENAL
-	if (idSoundSystemLocal::useOpenAL) {
+void idSoundChannel::ALStop( void ) {
+	if ( alIsSource( openalSource ) ) {
+		alSourceStop( openalSource );
+		alSourcei( openalSource, AL_BUFFER, 0 );
+		soundSystemLocal.FreeOpenALSource( openalSource );
+	}
 
-		if (alIsSource(openalSource)) {
-			alSourceStop(openalSource);
-			alSourcei(openalSource, AL_BUFFER, 0);
-#ifdef _OPENAL_EFX
-			// unassociate effect slot from source, so the effect slot can be deleted on shutdown
-			// even though the source itself is deleted later (in idSoundSystemLocal::Shutdown())
-			alSource3i( openalSource, AL_AUXILIARY_SEND_FILTER, AL_EFFECTSLOT_NULL, 0, AL_FILTER_NULL );
-#endif
-			soundSystemLocal.FreeOpenALSource(openalSource);
+	if ( openalStreamingBuffer[0] && openalStreamingBuffer[1] && openalStreamingBuffer[2] ) {
+		alGetError();
+		alDeleteBuffers( 3, &openalStreamingBuffer[0] );
+		if ( alGetError() == AL_NO_ERROR ) {
+			openalStreamingBuffer[0] = openalStreamingBuffer[1] = openalStreamingBuffer[2] = 0;
 		}
+	}
 
-		if (openalStreamingBuffer[0] && openalStreamingBuffer[1] && openalStreamingBuffer[2]) {
-			alGetError();
-			alDeleteBuffers(3, &openalStreamingBuffer[0]);
-
-			if (alGetError() == AL_NO_ERROR) {
-				openalStreamingBuffer[0] = openalStreamingBuffer[1] = openalStreamingBuffer[2] = 0;
-			}
+	if ( lastopenalStreamingBuffer[0] && lastopenalStreamingBuffer[1] && lastopenalStreamingBuffer[2] ) {
+		alGetError();
+		alDeleteBuffers( 3, &lastopenalStreamingBuffer[0] );
+		if ( alGetError() == AL_NO_ERROR ) {
+			lastopenalStreamingBuffer[0] = lastopenalStreamingBuffer[1] = lastopenalStreamingBuffer[2] = 0;
 		}
-
-		if (lastopenalStreamingBuffer[0] && lastopenalStreamingBuffer[1] && lastopenalStreamingBuffer[2]) {
-			alGetError();
-			alDeleteBuffers(3, &lastopenalStreamingBuffer[0]);
-
-			if (alGetError() == AL_NO_ERROR) {
-				lastopenalStreamingBuffer[0] = lastopenalStreamingBuffer[1] = lastopenalStreamingBuffer[2] = 0;
-			}
-		}
 	}
-#endif
 }
 
 /*
@@ -292,22 +257,19 @@ out of the range of the unlooped samples.  Handles loo
 samples and leadins
 ===================
 */
-void idSoundChannel::GatherChannelSamples(int sampleOffset44k, int sampleCount44k, float *dest) const
-{
+void idSoundChannel::GatherChannelSamples( int sampleOffset44k, int sampleCount44k, float *dest ) const {
 	float	*dest_p = dest;
 	int		len;
 
 //Sys_DebugPrintf( "msec:%i sample:%i : %i : %i\n", Sys_Milliseconds(), soundSystemLocal.GetCurrent44kHzTime(), sampleOffset44k, sampleCount44k );	//!@#
 
 	// negative offset times will just zero fill
-	if (sampleOffset44k < 0) {
+	if ( sampleOffset44k < 0 ) {
 		len = -sampleOffset44k;
-
-		if (len > sampleCount44k) {
+		if ( len > sampleCount44k ) {
 			len = sampleCount44k;
 		}
-
-		memset(dest_p, 0, len * sizeof(dest_p[0]));
+		memset( dest_p, 0, len * sizeof( dest_p[0] ) );
 		dest_p += len;
 		sampleCount44k -= len;
 		sampleOffset44k += len;
@@ -315,21 +277,19 @@ void idSoundChannel::GatherChannelSamples(int sampleOf
 
 	// grab part of the leadin sample
 	idSoundSample *leadin = leadinSample;
-
-	if (!leadin || sampleOffset44k < 0 || sampleCount44k <= 0) {
-		memset(dest_p, 0, sampleCount44k * sizeof(dest_p[0]));
+	if ( !leadin || sampleOffset44k < 0 || sampleCount44k <= 0 ) {
+		memset( dest_p, 0, sampleCount44k * sizeof( dest_p[0] ) );
 		return;
 	}
 
-	if (sampleOffset44k < leadin->LengthIn44kHzSamples()) {
+	if ( sampleOffset44k < leadin->LengthIn44kHzSamples() ) {
 		len = leadin->LengthIn44kHzSamples() - sampleOffset44k;
-
-		if (len > sampleCount44k) {
+		if ( len > sampleCount44k ) {
 			len = sampleCount44k;
 		}
 
 		// decode the sample
-		decoder->Decode(leadin, sampleOffset44k, len, dest_p);
+		decoder->Decode( leadin, sampleOffset44k, len, dest_p );
 
 		dest_p += len;
 		sampleCount44k -= len;
@@ -337,34 +297,33 @@ void idSoundChannel::GatherChannelSamples(int sampleOf
 	}
 
 	// if not looping, zero fill any remaining spots
-	if (!soundShader || !(parms.soundShaderFlags & SSF_LOOPING)) {
-		memset(dest_p, 0, sampleCount44k * sizeof(dest_p[0]));
+	if ( !soundShader || !( parms.soundShaderFlags & SSF_LOOPING ) ) {
+		memset( dest_p, 0, sampleCount44k * sizeof( dest_p[0] ) );
 		return;
 	}
 
 	// fill the remainder with looped samples
 	idSoundSample *loop = soundShader->entries[0];
 
-	if (!loop) {
-		memset(dest_p, 0, sampleCount44k * sizeof(dest_p[0]));
+	if ( !loop ) {
+		memset( dest_p, 0, sampleCount44k * sizeof( dest_p[0] ) );
 		return;
 	}
 
 	sampleOffset44k -= leadin->LengthIn44kHzSamples();
 
-	while (sampleCount44k > 0) {
+	while( sampleCount44k > 0 ) {
 		int totalLen = loop->LengthIn44kHzSamples();
 
 		sampleOffset44k %= totalLen;
 
 		len = totalLen - sampleOffset44k;
-
-		if (len > sampleCount44k) {
+		if ( len > sampleCount44k ) {
 			len = sampleCount44k;
 		}
 
 		// decode the sample
-		decoder->Decode(loop, sampleOffset44k, len, dest_p);
+		decoder->Decode( loop, sampleOffset44k, len, dest_p );
 
 		dest_p += len;
 		sampleCount44k -= len;
@@ -381,8 +340,7 @@ idSoundEmitterLocal::idSoundEmitterLocal
 
 ===============
 */
-idSoundEmitterLocal::idSoundEmitterLocal(void)
-{
+idSoundEmitterLocal::idSoundEmitterLocal( void ) {
 	soundWorld = NULL;
 	Clear();
 }
@@ -392,8 +350,7 @@ idSoundEmitterLocal::idSoundEmitterLocal(void)
 idSoundEmitterLocal::~idSoundEmitterLocal
 ===============
 */
-idSoundEmitterLocal::~idSoundEmitterLocal(void)
-{
+idSoundEmitterLocal::~idSoundEmitterLocal( void ) {
 	Clear();
 }
 
@@ -402,11 +359,10 @@ idSoundEmitterLocal::~idSoundEmitterLocal(void)
 idSoundEmitterLocal::Clear
 ===============
 */
-void idSoundEmitterLocal::Clear(void)
-{
+void idSoundEmitterLocal::Clear( void ) {
 	int i;
 
-	for (i = 0; i < SOUND_MAX_CHANNELS; i++) {
+	for( i = 0; i < SOUND_MAX_CHANNELS; i++ ) {
 		channels[i].ALStop();
 		channels[i].Clear();
 	}
@@ -423,7 +379,7 @@ void idSoundEmitterLocal::Clear(void)
 	maxDistance = 10.0f;						// meters
 	spatializedOrigin.Zero();
 
-	memset(&parms, 0, sizeof(parms));
+	memset( &parms, 0, sizeof( parms ) );
 #ifdef _HUMANHEAD
 	parms.subIndex = -1;
 #endif
@@ -434,39 +390,33 @@ void idSoundEmitterLocal::Clear(void)
 idSoundEmitterLocal::OverrideParms
 ==================
 */
-void idSoundEmitterLocal::OverrideParms(const soundShaderParms_t *base,
-                                        const soundShaderParms_t *over, soundShaderParms_t *out)
-{
-	if (!over) {
+void idSoundEmitterLocal::OverrideParms( const soundShaderParms_t *base,
+									  const soundShaderParms_t *over, soundShaderParms_t *out ) {
+	if ( !over ) {
 		*out = *base;
 		return;
 	}
-
-	if (over->minDistance) {
+	if ( over->minDistance ) {
 		out->minDistance = over->minDistance;
 	} else {
 		out->minDistance = base->minDistance;
 	}
-
-	if (over->maxDistance) {
+	if ( over->maxDistance ) {
 		out->maxDistance = over->maxDistance;
 	} else {
 		out->maxDistance = base->maxDistance;
 	}
-
-	if (over->shakes) {
+	if ( over->shakes ) {
 		out->shakes = over->shakes;
 	} else {
 		out->shakes = base->shakes;
 	}
-
-	if (over->volume) {
+	if ( over->volume ) {
 		out->volume = over->volume;
 	} else {
 		out->volume = base->volume;
 	}
-
-	if (over->soundClass) {
+	if ( over->soundClass ) {
 		out->soundClass = over->soundClass;
 	} else {
 		out->soundClass = base->soundClass;
@@ -497,7 +447,6 @@ void idSoundEmitterLocal::OverrideParms(const soundSha
 		out->profanityDuration = base->profanityDuration;
 	}
 #endif
-
 	out->soundShaderFlags = base->soundShaderFlags | over->soundShaderFlags;
 }
 
@@ -509,87 +458,74 @@ Checks to see if all the channels have completed, clea
 Sets the playing and shakes bools.
 ==================
 */
-void idSoundEmitterLocal::CheckForCompletion(int current44kHzTime)
-{
+void idSoundEmitterLocal::CheckForCompletion( int current44kHzTime ) {
 	bool hasActive;
 	int i;
 
 	hasActive = false;
 	hasShakes = false;
 
-	if (playing) {
-		for (i = 0; i < SOUND_MAX_CHANNELS; i++) {
+	if ( playing ) {
+		for ( i = 0; i < SOUND_MAX_CHANNELS; i++ ) {
 			idSoundChannel	*chan = &channels[i];
 
-			if (!chan->triggerState) {
+			if ( !chan->triggerState ) {
 				continue;
 			}
-
 			const idSoundShader *shader = chan->soundShader;
-
-			if (!shader) {
+			if ( !shader ) {
 				continue;
 			}
 
 			// see if this channel has completed
-			if (!(chan->parms.soundShaderFlags & SSF_LOOPING)) {
-#ifdef _OPENAL
+			if ( !( chan->parms.soundShaderFlags & SSF_LOOPING ) ) {
 				ALint state = AL_PLAYING;
-				if (idSoundSystemLocal::useOpenAL && alIsSource(chan->openalSource)) {
-					alGetSourcei(chan->openalSource, AL_SOURCE_STATE, &state);
+
+				if ( alIsSource( chan->openalSource ) ) {
+					alGetSourcei( chan->openalSource, AL_SOURCE_STATE, &state );
 				}
-#endif
+				idSlowChannel slow = GetSlowChannel( chan );
 
-				idSlowChannel slow = GetSlowChannel(chan);
-
-				if (soundWorld->slowmoActive && slow.IsActive()) {
-					if (slow.GetCurrentPosition().time >= chan->leadinSample->LengthIn44kHzSamples() / 2) {
+				if ( soundWorld->slowmoActive && slow.IsActive() ) {
+					if ( slow.GetCurrentPosition().time >= chan->leadinSample->LengthIn44kHzSamples() / 2 ) {
 						chan->Stop();
-
 						// if this was an onDemand sound, purge the sample now
-						if (chan->leadinSample->onDemand) {
+						if ( chan->leadinSample->onDemand ) {
 							chan->leadinSample->PurgeSoundSample();
 						}
-
 						continue;
 					}
-				} else if ((chan->trigger44kHzTime + chan->leadinSample->LengthIn44kHzSamples() < current44kHzTime)
-#ifdef _OPENAL
-                    || ( state == AL_STOPPED ) //k: 2024
-#endif
-				) {
+				} else if ( ( chan->trigger44kHzTime + chan->leadinSample->LengthIn44kHzSamples() < current44kHzTime ) || ( state == AL_STOPPED ) ) {
 					chan->Stop();
 
 					// free hardware resources
 					chan->ALStop();
 
 					// if this was an onDemand sound, purge the sample now
-					if (chan->leadinSample->onDemand) {
+					if ( chan->leadinSample->onDemand ) {
 						chan->leadinSample->PurgeSoundSample();
 					}
-
 					continue;
 				}
 			}
 
 			// free decoder memory if no sound was decoded for a while
-			if (chan->decoder != NULL && chan->decoder->GetLastDecodeTime() < current44kHzTime - SOUND_DECODER_FREE_DELAY) {
+			if ( chan->decoder != NULL && chan->decoder->GetLastDecodeTime() < current44kHzTime - SOUND_DECODER_FREE_DELAY ) {
 				chan->decoder->ClearDecoder();
 			}
 
 			hasActive = true;
 
-			if (chan->parms.shakes > 0.0f) {
+			if ( chan->parms.shakes > 0.0f ) {
 				hasShakes = true;
 			}
 		}
 	}
 
 	// mark the entire sound emitter as non-playing if there aren't any active channels
-	if (!hasActive) {
+	if ( !hasActive ) {
 		playing = false;
-
-		if (removeStatus == REMOVE_STATUS_WAITSAMPLEFINISHED) {
+		if ( removeStatus == REMOVE_STATUS_WAITSAMPLEFINISHED ) {
 			// this can now be reused by the next request for a new soundEmitter
 			removeStatus = REMOVE_STATUS_SAMPLEFINISHED;
 		}
@@ -603,24 +539,21 @@ idSoundEmitterLocal::Spatialize
 Called once each sound frame by the main thread from idSoundWorldLocal::PlaceOrigin
 ===================
 */
-void idSoundEmitterLocal::Spatialize(idVec3 listenerPos, int listenerArea, idRenderWorld *rw)
-{
+void idSoundEmitterLocal::Spatialize( idVec3 listenerPos, int listenerArea, idRenderWorld *rw ) {
 	int			i;
-	bool		hasActive = false;
 
 	//
 	// work out the maximum distance of all the playing channels
 	//
 	maxDistance = 0;
 
-	for (i = 0; i < SOUND_MAX_CHANNELS; i++) {
+	for ( i = 0; i < SOUND_MAX_CHANNELS; i++ ) {
 		idSoundChannel	*chan = &channels[i];
 
-		if (!chan->triggerState) {
+		if ( !chan->triggerState ) {
 			continue;
 		}
-
-		if (chan->parms.maxDistance > maxDistance) {
+		if ( chan->parms.maxDistance > maxDistance ) {
 			maxDistance = chan->parms.maxDistance;
 		}
 	}
@@ -632,7 +565,7 @@ void idSoundEmitterLocal::Spatialize(idVec3 listenerPo
 	idVec3 len = listenerPos - realOrigin;
 	realDistance = len.LengthFast();
 
-	if (realDistance >= maxDistance) {
+	if ( realDistance >= maxDistance ) {
 		// no way to possibly hear it
 		distance = realDistance;
 		return;
@@ -642,34 +575,28 @@ void idSoundEmitterLocal::Spatialize(idVec3 listenerPo
 	// work out virtual origin and distance, which may be from a portal instead of the actual origin
 	//
 	distance = maxDistance * METERS_TO_DOOM;
-
-	if (listenerArea == -1) {		// listener is outside the world
+	if ( listenerArea == -1 ) {		// listener is outside the world
 		return;
 	}
-
-	if (rw) {
+	if ( rw ) {
 		// we have a valid renderWorld
-		int soundInArea = rw->PointInArea(origin);
-
-		if (soundInArea == -1) {
-			if (lastValidPortalArea == -1) {		// sound is outside the world
+		int soundInArea = rw->PointInArea( origin );
+		if ( soundInArea == -1 ) {
+			if ( lastValidPortalArea == -1 ) {		// sound is outside the world
 				distance = realDistance;
 				spatializedOrigin = origin;			// sound is in our area
 				return;
 			}
-
 			soundInArea = lastValidPortalArea;
 		}
-
 		lastValidPortalArea = soundInArea;
-
-		if (soundInArea == listenerArea) {
+		if ( soundInArea == listenerArea ) {
 			distance = realDistance;
 			spatializedOrigin = origin;			// sound is in our area
 			return;
 		}
 
-		soundWorld->ResolveOrigin(0, NULL, soundInArea, 0.0f, origin, this);
+		soundWorld->ResolveOrigin( 0, NULL, soundInArea, 0.0f, origin, this );
 		distance /= METERS_TO_DOOM;
 	} else {
 		// no portals available
@@ -691,24 +618,22 @@ PUBLIC FUNCTIONS
 idSoundEmitterLocal::UpdateEmitter
 =====================
 */
-void idSoundEmitterLocal::UpdateEmitter(const idVec3 &origin, int listenerId, const soundShaderParms_t *parms)
-{
-	if (!parms) {
-		common->Error("idSoundEmitterLocal::UpdateEmitter: NULL parms");
+void idSoundEmitterLocal::UpdateEmitter( const idVec3 &origin, int listenerId, const soundShaderParms_t *parms ) {
+	if ( !parms ) {
+		common->Error( "idSoundEmitterLocal::UpdateEmitter: NULL parms" );
 	}
-
-	if (soundWorld && soundWorld->writeDemo) {
-		soundWorld->writeDemo->WriteInt(DS_SOUND);
-		soundWorld->writeDemo->WriteInt(SCMD_UPDATE);
-		soundWorld->writeDemo->WriteInt(index);
-		soundWorld->writeDemo->WriteVec3(origin);
-		soundWorld->writeDemo->WriteInt(listenerId);
-		soundWorld->writeDemo->WriteFloat(parms->minDistance);
-		soundWorld->writeDemo->WriteFloat(parms->maxDistance);
-		soundWorld->writeDemo->WriteFloat(parms->volume);
-		soundWorld->writeDemo->WriteFloat(parms->shakes);
-		soundWorld->writeDemo->WriteInt(parms->soundShaderFlags);
-		soundWorld->writeDemo->WriteInt(parms->soundClass);
+	if ( soundWorld && soundWorld->writeDemo ) {
+		soundWorld->writeDemo->WriteInt( DS_SOUND );
+		soundWorld->writeDemo->WriteInt( SCMD_UPDATE );
+		soundWorld->writeDemo->WriteInt( index );
+		soundWorld->writeDemo->WriteVec3( origin );
+		soundWorld->writeDemo->WriteInt( listenerId );
+		soundWorld->writeDemo->WriteFloat( parms->minDistance );
+		soundWorld->writeDemo->WriteFloat( parms->maxDistance );
+		soundWorld->writeDemo->WriteFloat( parms->volume );
+		soundWorld->writeDemo->WriteFloat( parms->shakes );
+		soundWorld->writeDemo->WriteInt( parms->soundShaderFlags );
+		soundWorld->writeDemo->WriteInt( parms->soundClass );
 	}
 
 	this->origin = origin;
@@ -725,24 +650,22 @@ idSoundEmitterLocal::Free
 They are never truly freed, just marked so they can be reused by the soundWorld
 =====================
 */
-void idSoundEmitterLocal::Free(bool immediate)
-{
-	if (removeStatus != REMOVE_STATUS_ALIVE) {
+void idSoundEmitterLocal::Free( bool immediate ) {
+	if ( removeStatus != REMOVE_STATUS_ALIVE ) {
 		return;
 	}
 
-	if (idSoundSystemLocal::s_showStartSound.GetInteger()) {
-		common->Printf("FreeSound (%i,%i)\n",  index, (int)immediate);
+	if ( idSoundSystemLocal::s_showStartSound.GetInteger() ) {
+		common->Printf( "FreeSound (%i,%i)\n",  index, (int)immediate );
 	}
-
-	if (soundWorld && soundWorld->writeDemo) {
-		soundWorld->writeDemo->WriteInt(DS_SOUND);
-		soundWorld->writeDemo->WriteInt(SCMD_FREE);
-		soundWorld->writeDemo->WriteInt(index);
-		soundWorld->writeDemo->WriteInt(immediate);
+	if ( soundWorld && soundWorld->writeDemo ) {
+		soundWorld->writeDemo->WriteInt( DS_SOUND );
+		soundWorld->writeDemo->WriteInt( SCMD_FREE );
+		soundWorld->writeDemo->WriteInt( index );
+		soundWorld->writeDemo->WriteInt( immediate );
 	}
 
-	if (!immediate) {
+	if ( !immediate ) {
 		removeStatus = REMOVE_STATUS_WAITSAMPLEFINISHED;
 	} else {
 		Clear();
@@ -756,45 +679,44 @@ idSoundEmitterLocal::StartSound
 returns the length of the started sound in msec
 =====================
 */
-int idSoundEmitterLocal::StartSound(const idSoundShader *shader, const s_channelType channel, float diversity, int soundShaderFlags, bool allowSlow)
-{
+int idSoundEmitterLocal::StartSound( const idSoundShader *shader, const s_channelType channel, float diversity, int soundShaderFlags, bool allowSlow ) {
 	int i;
 
-	if (!shader) {
+	if ( !shader ) {
 		return 0;
 	}
 
-	if (idSoundSystemLocal::s_showStartSound.GetInteger()) {
-		common->Printf("StartSound %ims (%i,%i,%s) = ", soundWorld->gameMsec, index, (int)channel, shader->GetName());
+	if ( idSoundSystemLocal::s_showStartSound.GetInteger() ) {
+		common->Printf( "StartSound %ims (%i,%i,%s) = ", soundWorld->gameMsec, index, (int)channel, shader->GetName() );
 	}
 
-	if (soundWorld && soundWorld->writeDemo) {
-		soundWorld->writeDemo->WriteInt(DS_SOUND);
-		soundWorld->writeDemo->WriteInt(SCMD_START);
-		soundWorld->writeDemo->WriteInt(index);
+	if ( soundWorld && soundWorld->writeDemo ) {
+		soundWorld->writeDemo->WriteInt( DS_SOUND );
+		soundWorld->writeDemo->WriteInt( SCMD_START );
+		soundWorld->writeDemo->WriteInt( index );
 
-		soundWorld->writeDemo->WriteHashString(shader->GetName());
+		soundWorld->writeDemo->WriteHashString( shader->GetName() );
 
-		soundWorld->writeDemo->WriteInt(channel);
-		soundWorld->writeDemo->WriteFloat(diversity);
-		soundWorld->writeDemo->WriteInt(soundShaderFlags);
+		soundWorld->writeDemo->WriteInt( channel );
+		soundWorld->writeDemo->WriteFloat( diversity );
+		soundWorld->writeDemo->WriteInt( soundShaderFlags );
 	}
 
 	// build the channel parameters by taking the shader parms and optionally overriding
 	soundShaderParms_t	chanParms;
 
 	chanParms = shader->parms;
-	OverrideParms(&chanParms, &this->parms, &chanParms);
+	OverrideParms( &chanParms, &this->parms, &chanParms );
 	chanParms.soundShaderFlags |= soundShaderFlags;
 
-	if (chanParms.shakes > 0.0f) {
+	if ( chanParms.shakes > 0.0f ) {
 		shader->CheckShakesAndOgg();
 	}
 
 	// this is the sample time it will be first mixed
 	int start44kHz;
 
-	if (soundWorld->fpa[0]) {
+	if ( soundWorld->fpa[0] ) {
 		// if we are recording an AVI demo, don't use hardware time
 		start44kHz = soundWorld->lastAVI44kHz + MIXBUFFER_SAMPLES;
 	} else {
@@ -804,53 +726,45 @@ int idSoundEmitterLocal::StartSound(const idSoundShade
 	//
 	// pick which sound to play from the shader
 	//
-	if (!shader->numEntries) {
-		if (idSoundSystemLocal::s_showStartSound.GetInteger()) {
-			common->Printf("no samples in sound shader\n");
+	if ( !shader->numEntries ) {
+		if ( idSoundSystemLocal::s_showStartSound.GetInteger() ) {
+			common->Printf( "no samples in sound shader\n" );
 		}
-
 		return 0;				// no sounds
 	}
-
 	int choice;
 
 	// pick a sound from the list based on the passed diversity
 	choice = (int)(diversity * shader->numEntries);
-
-	if (choice < 0 || choice >= shader->numEntries) {
+	if ( choice < 0 || choice >= shader->numEntries ) {
 		choice = 0;
 	}
 
 	// bump the choice if the exact sound was just played and we are NO_DUPS
-	if (chanParms.soundShaderFlags & SSF_NO_DUPS) {
+	if ( chanParms.soundShaderFlags & SSF_NO_DUPS ) {
 		idSoundSample	*sample;
-
-		if (shader->leadins[ choice ]) {
+		if ( shader->leadins[ choice ] ) {
 			sample = shader->leadins[ choice ];
 		} else {
 			sample = shader->entries[ choice ];
 		}
-
-		for (i = 0; i < SOUND_MAX_CHANNELS; i++) {
+		for( i = 0; i < SOUND_MAX_CHANNELS; i++ ) {
 			idSoundChannel	*chan = &channels[i];
-
-			if (chan->leadinSample == sample) {
-				choice = (choice + 1) % shader->numEntries;
+			if ( chan->leadinSample == sample ) {
+				choice = ( choice + 1 ) % shader->numEntries;
 				break;
 			}
 		}
 	}
 
 	// PLAY_ONCE sounds will never be restarted while they are running
-	if (chanParms.soundShaderFlags & SSF_PLAY_ONCE) {
-		for (i = 0; i < SOUND_MAX_CHANNELS; i++) {
+	if ( chanParms.soundShaderFlags & SSF_PLAY_ONCE ) {
+		for( i = 0; i < SOUND_MAX_CHANNELS; i++ ) {
 			idSoundChannel	*chan = &channels[i];
-
-			if (chan->triggerState && chan->soundShader == shader) {
-				if (idSoundSystemLocal::s_showStartSound.GetInteger()) {
-					common->Printf("PLAY_ONCE not restarting\n");
+			if ( chan->triggerState && chan->soundShader == shader ) {
+				if ( idSoundSystemLocal::s_showStartSound.GetInteger() ) {
+					common->Printf( "PLAY_ONCE not restarting\n" );
 				}
-
 				return 0;
 			}
 		}
@@ -858,14 +772,12 @@ int idSoundEmitterLocal::StartSound(const idSoundShade
 
 	// never play the same sound twice with the same starting time, even
 	// if they are on different channels
-	for (i = 0; i < SOUND_MAX_CHANNELS; i++) {
+	for( i = 0; i < SOUND_MAX_CHANNELS; i++ ) {
 		idSoundChannel	*chan = &channels[i];
-
-		if (chan->triggerState && chan->soundShader == shader && chan->trigger44kHzTime == start44kHz) {
-			if (idSoundSystemLocal::s_showStartSound.GetInteger()) {
-				common->Printf("already started this frame\n");
+		if ( chan->triggerState && chan->soundShader == shader && chan->trigger44kHzTime == start44kHz ) {
+			if ( idSoundSystemLocal::s_showStartSound.GetInteger() ) {
+				common->Printf( "already started this frame\n" );
 			}
-
 			return 0;
 		}
 	}
@@ -873,23 +785,21 @@ int idSoundEmitterLocal::StartSound(const idSoundShade
 	Sys_EnterCriticalSection();
 
 	// kill any sound that is currently playing on this channel
-	if (channel != SCHANNEL_ANY) {
-		for (i = 0; i < SOUND_MAX_CHANNELS; i++) {
+	if ( channel != SCHANNEL_ANY ) {
+		for( i = 0; i < SOUND_MAX_CHANNELS; i++ ) {
 			idSoundChannel	*chan = &channels[i];
-
-			if (chan->triggerState && chan->soundShader && chan->triggerChannel == channel) {
-				if (idSoundSystemLocal::s_showStartSound.GetInteger()) {
-					common->Printf("(override %s)", chan->soundShader->base->GetName());
+			if ( chan->triggerState && chan->soundShader && chan->triggerChannel == channel ) {
+				if ( idSoundSystemLocal::s_showStartSound.GetInteger() ) {
+					common->Printf( "(override %s)", chan->soundShader->base->GetName() );
 				}
 
 				chan->Stop();
 
 				// if this was an onDemand sound, purge the sample now
-				if (chan->leadinSample->onDemand) {
+				if ( chan->leadinSample->onDemand ) {
 					chan->ALStop();
 					chan->leadinSample->PurgeSoundSample();
 				}
-
 				break;
 			}
 		}
@@ -897,58 +807,53 @@ int idSoundEmitterLocal::StartSound(const idSoundShade
 
 	// find a free channel to play the sound on
 	idSoundChannel	*chan;
-
-	for (i = 0; i < SOUND_MAX_CHANNELS; i++) {
+	for( i = 0; i < SOUND_MAX_CHANNELS; i++ ) {
 		chan = &channels[i];
-
-		if (!chan->triggerState) {
+		if ( !chan->triggerState ) {
 			break;
 		}
 	}
 
-	if (i == SOUND_MAX_CHANNELS) {
+	if ( i == SOUND_MAX_CHANNELS ) {
 		// we couldn't find a channel for it
 		Sys_LeaveCriticalSection();
-
-		if (idSoundSystemLocal::s_showStartSound.GetInteger()) {
-			common->Printf("no channels available\n");
+		if ( idSoundSystemLocal::s_showStartSound.GetInteger() ) {
+			common->Printf( "no channels available\n" );
 		}
-
 		return 0;
 	}
 
 	chan = &channels[i];
 
-	if (shader->leadins[ choice ]) {
+	if ( shader->leadins[ choice ] ) {
 		chan->leadinSample = shader->leadins[ choice ];
 	} else {
 		chan->leadinSample = shader->entries[ choice ];
 	}
 
 	// if the sample is onDemand (voice mails, etc), load it now
-	if (chan->leadinSample->purged) {
+	if ( chan->leadinSample->purged ) {
 		int		start = Sys_Milliseconds();
 		chan->leadinSample->Load();
 		int		end = Sys_Milliseconds();
-		session->TimeHitch(end - start);
-
+		session->TimeHitch( end - start );
 		// recalculate start44kHz, because loading may have taken a fair amount of time
-		if (!soundWorld->fpa[0]) {
+		if ( !soundWorld->fpa[0] ) {
 			start44kHz = soundSystemLocal.GetCurrent44kHzTime() + MIXBUFFER_SAMPLES;
 		}
 	}
 
-	if (idSoundSystemLocal::s_showStartSound.GetInteger()) {
-		common->Printf("'%s'\n", chan->leadinSample->name.c_str());
+	if ( idSoundSystemLocal::s_showStartSound.GetInteger() ) {
+		common->Printf( "'%s'\n", chan->leadinSample->name.c_str() );
 	}
 
-	if (idSoundSystemLocal::s_skipHelltimeFX.GetBool()) {
+	if ( idSoundSystemLocal::s_skipHelltimeFX.GetBool() ) {
 		chan->disallowSlow = true;
 	} else {
 		chan->disallowSlow = !allowSlow;
 	}
 
-	ResetSlowChannel(chan);
+	ResetSlowChannel( chan );
 
 	// the sound will start mixing in the next async mix block
 	chan->triggered = true;
@@ -965,21 +870,21 @@ int idSoundEmitterLocal::StartSound(const idSoundShade
 
 	// spatialize it immediately, so it will start the next mix block
 	// even if that happens before the next PlaceOrigin()
-	Spatialize(soundWorld->listenerPos, soundWorld->listenerArea, soundWorld->rw);
+	Spatialize( soundWorld->listenerPos, soundWorld->listenerArea, soundWorld->rw );
 
 	// return length of sound in milliseconds
 	int length = chan->leadinSample->LengthIn44kHzSamples();
 
-	if (chan->leadinSample->objectInfo.nChannels == 2) {
+	if ( chan->leadinSample->objectInfo.nChannels == 2 ) {
 		length /= 2;	// stereo samples
 	}
 
 	// adjust the start time based on diversity for looping sounds, so they don't all start
 	// at the same point
-	if (chan->parms.soundShaderFlags & SSF_LOOPING && !chan->leadinSample->LengthIn44kHzSamples()) {
+	if ( chan->parms.soundShaderFlags & SSF_LOOPING && !chan->leadinSample->LengthIn44kHzSamples() ) {
 		chan->trigger44kHzTime -= diversity * length;
 		chan->trigger44kHzTime &= ~7;		// so we don't have to worry about the 22kHz and 11kHz expansions
-		// starting in fractional samples
+											// starting in fractional samples
 		chan->triggerGame44kHzTime -= diversity * length;
 		chan->triggerGame44kHzTime &= ~7;
 	}
@@ -996,43 +901,39 @@ int idSoundEmitterLocal::StartSound(const idSoundShade
 idSoundEmitterLocal::ModifySound
 ===================
 */
-void idSoundEmitterLocal::ModifySound(const s_channelType channel, const soundShaderParms_t *parms)
-{
-	if (!parms) {
-		common->Error("idSoundEmitterLocal::ModifySound: NULL parms");
+void idSoundEmitterLocal::ModifySound( const s_channelType channel, const soundShaderParms_t *parms ) {
+	if ( !parms ) {
+		common->Error( "idSoundEmitterLocal::ModifySound: NULL parms" );
 	}
-
-	if (idSoundSystemLocal::s_showStartSound.GetInteger()) {
-		common->Printf("ModifySound(%i,%i)\n", index, channel);
+	if ( idSoundSystemLocal::s_showStartSound.GetInteger() ) {
+		common->Printf( "ModifySound(%i,%i)\n", index, channel );
 	}
-
-	if (soundWorld && soundWorld->writeDemo) {
-		soundWorld->writeDemo->WriteInt(DS_SOUND);
-		soundWorld->writeDemo->WriteInt(SCMD_MODIFY);
-		soundWorld->writeDemo->WriteInt(index);
-		soundWorld->writeDemo->WriteInt(channel);
-		soundWorld->writeDemo->WriteFloat(parms->minDistance);
-		soundWorld->writeDemo->WriteFloat(parms->maxDistance);
-		soundWorld->writeDemo->WriteFloat(parms->volume);
-		soundWorld->writeDemo->WriteFloat(parms->shakes);
-		soundWorld->writeDemo->WriteInt(parms->soundShaderFlags);
-		soundWorld->writeDemo->WriteInt(parms->soundClass);
+	if ( soundWorld && soundWorld->writeDemo ) {
+		soundWorld->writeDemo->WriteInt( DS_SOUND );
+		soundWorld->writeDemo->WriteInt( SCMD_MODIFY );
+		soundWorld->writeDemo->WriteInt( index );
+		soundWorld->writeDemo->WriteInt( channel );
+		soundWorld->writeDemo->WriteFloat( parms->minDistance );
+		soundWorld->writeDemo->WriteFloat( parms->maxDistance );
+		soundWorld->writeDemo->WriteFloat( parms->volume );
+		soundWorld->writeDemo->WriteFloat( parms->shakes );
+		soundWorld->writeDemo->WriteInt( parms->soundShaderFlags );
+		soundWorld->writeDemo->WriteInt( parms->soundClass );
 	}
 
-	for (int i = 0; i < SOUND_MAX_CHANNELS; i++) {
+	for ( int i = 0; i < SOUND_MAX_CHANNELS; i++ ) {
 		idSoundChannel	*chan = &channels[i];
 
-		if (!chan->triggerState) {
+		if ( !chan->triggerState ) {
 			continue;
 		}
-
-		if (channel != SCHANNEL_ANY && chan->triggerChannel != channel) {
+		if ( channel != SCHANNEL_ANY && chan->triggerChannel != channel ) {
 			continue;
 		}
 
-		OverrideParms(&chan->parms, parms, &chan->parms);
+		OverrideParms( &chan->parms, parms, &chan->parms );
 
-		if (chan->parms.shakes > 0.0f && chan->soundShader != NULL) {
+		if ( chan->parms.shakes > 0.0f && chan->soundShader != NULL ) {
 			chan->soundShader->CheckShakesAndOgg();
 		}
 	}
@@ -1045,39 +946,43 @@ idSoundEmitterLocal::StopSound
 can pass SCHANNEL_ANY
 ===================
 */
-void idSoundEmitterLocal::StopSound(const s_channelType channel)
-{
+void idSoundEmitterLocal::StopSound( const s_channelType channel ) {
 	int i;
 
-	if (idSoundSystemLocal::s_showStartSound.GetInteger()) {
-		common->Printf("StopSound(%i,%i)\n", index, channel);
+	if ( idSoundSystemLocal::s_showStartSound.GetInteger() ) {
+		common->Printf( "StopSound(%i,%i)\n", index, channel );
 	}
 
-	if (soundWorld && soundWorld->writeDemo) {
-		soundWorld->writeDemo->WriteInt(DS_SOUND);
-		soundWorld->writeDemo->WriteInt(SCMD_STOP);
-		soundWorld->writeDemo->WriteInt(index);
-		soundWorld->writeDemo->WriteInt(channel);
+	if ( soundWorld && soundWorld->writeDemo ) {
+		soundWorld->writeDemo->WriteInt( DS_SOUND );
+		soundWorld->writeDemo->WriteInt( SCMD_STOP );
+		soundWorld->writeDemo->WriteInt( index );
+		soundWorld->writeDemo->WriteInt( channel );
 	}
 
 	Sys_EnterCriticalSection();
 
-	for (i = 0; i < SOUND_MAX_CHANNELS; i++) {
+	for( i = 0; i < SOUND_MAX_CHANNELS; i++ ) {
 		idSoundChannel	*chan = &channels[i];
-		if (!chan->triggerState) {
+
+		if ( !chan->triggerState ) {
 			continue;
 		}
-		if (channel != SCHANNEL_ANY && chan->triggerChannel != channel) {
+		if ( channel != SCHANNEL_ANY && chan->triggerChannel != channel ) {
 			continue;
 		}
+
 		// stop it
 		chan->Stop();
+
 		// free hardware resources
 		chan->ALStop();
+
 		// if this was an onDemand sound, purge the sample now
-		if (chan->leadinSample && chan->leadinSample->onDemand) {
+		if ( chan->leadinSample->onDemand ) {
 			chan->leadinSample->PurgeSoundSample();
 		}
+
 		chan->leadinSample = NULL;
 		chan->soundShader = NULL;
 	}
@@ -1092,55 +997,51 @@ idSoundEmitterLocal::FadeSound
 to is in Db (sigh), over is in seconds
 ===================
 */
-void idSoundEmitterLocal::FadeSound(const s_channelType channel, float to, float over)
-{
-	if (idSoundSystemLocal::s_showStartSound.GetInteger()) {
-		common->Printf("FadeSound(%i,%i,%f,%f )\n", index, channel, to, over);
+void idSoundEmitterLocal::FadeSound( const s_channelType channel, float to, float over ) {
+	if ( idSoundSystemLocal::s_showStartSound.GetInteger() ) {
+		common->Printf( "FadeSound(%i,%i,%f,%f )\n", index, channel, to, over );
 	}
-
-	if (!soundWorld) {
+	if ( !soundWorld ) {
 		return;
 	}
-
-	if (soundWorld->writeDemo) {
-		soundWorld->writeDemo->WriteInt(DS_SOUND);
-		soundWorld->writeDemo->WriteInt(SCMD_FADE);
-		soundWorld->writeDemo->WriteInt(index);
-		soundWorld->writeDemo->WriteInt(channel);
-		soundWorld->writeDemo->WriteFloat(to);
-		soundWorld->writeDemo->WriteFloat(over);
+	if ( soundWorld->writeDemo ) {
+		soundWorld->writeDemo->WriteInt( DS_SOUND );
+		soundWorld->writeDemo->WriteInt( SCMD_FADE );
+		soundWorld->writeDemo->WriteInt( index );
+		soundWorld->writeDemo->WriteInt( channel );
+		soundWorld->writeDemo->WriteFloat( to );
+		soundWorld->writeDemo->WriteFloat( over );
 	}
 
 	int	start44kHz;
 
-	if (soundWorld->fpa[0]) {
+	if ( soundWorld->fpa[0] ) {
 		// if we are recording an AVI demo, don't use hardware time
 		start44kHz = soundWorld->lastAVI44kHz + MIXBUFFER_SAMPLES;
 	} else {
 		start44kHz = soundSystemLocal.GetCurrent44kHzTime() + MIXBUFFER_SAMPLES;
 	}
 
-	int	length44kHz = soundSystemLocal.MillisecondsToSamples(over * 1000);
+	int	length44kHz = soundSystemLocal.MillisecondsToSamples( over * 1000 );
 
-	for (int i = 0; i < SOUND_MAX_CHANNELS ; i++) {
+	for( int i = 0; i < SOUND_MAX_CHANNELS ; i++ ) {
 		idSoundChannel	*chan = &channels[i];
 
-		if (!chan->triggerState) {
+		if ( !chan->triggerState ) {
 			continue;
 		}
-
-		if (channel != SCHANNEL_ANY && chan->triggerChannel != channel) {
+		if ( channel != SCHANNEL_ANY && chan->triggerChannel != channel ) {
 			continue;
 		}
 
 		// if it is already fading to this volume at this rate, don't change it
-		if (chan->channelFade.fadeEndVolume == to &&
-		    chan->channelFade.fadeEnd44kHz - chan->channelFade.fadeStart44kHz == length44kHz) {
+		if ( chan->channelFade.fadeEndVolume == to &&
+			chan->channelFade.fadeEnd44kHz - chan->channelFade.fadeStart44kHz == length44kHz ) {
 			continue;
 		}
 
 		// fade it
-		chan->channelFade.fadeStartVolume = chan->channelFade.FadeDbAt44kHz(start44kHz);
+		chan->channelFade.fadeStartVolume = chan->channelFade.FadeDbAt44kHz( start44kHz );
 		chan->channelFade.fadeStart44kHz = start44kHz;
 		chan->channelFade.fadeEnd44kHz = start44kHz + length44kHz;
 		chan->channelFade.fadeEndVolume = to;
@@ -1152,8 +1053,7 @@ void idSoundEmitterLocal::FadeSound(const s_channelTyp
 idSoundEmitterLocal::CurrentlyPlaying
 ===================
 */
-bool idSoundEmitterLocal::CurrentlyPlaying(void) const
-{
+bool idSoundEmitterLocal::CurrentlyPlaying( void ) const {
 	return playing;
 }
 
@@ -1162,8 +1062,7 @@ bool idSoundEmitterLocal::CurrentlyPlaying(void) const
 idSoundEmitterLocal::Index
 ===================
 */
-int	idSoundEmitterLocal::Index(void) const
-{
+int	idSoundEmitterLocal::Index( void ) const {
 	return index;
 }
 
@@ -1175,26 +1074,25 @@ this is called from the main thread by the material sh
 to allow lights and surface flares to vary with the sound amplitude
 ===================
 */
-float idSoundEmitterLocal::CurrentAmplitude(void)
-{
-	if (idSoundSystemLocal::s_constantAmplitude.GetFloat() >= 0.0f) {
+float idSoundEmitterLocal::CurrentAmplitude( void ) {
+	if ( idSoundSystemLocal::s_constantAmplitude.GetFloat() >= 0.0f ) {
 		return idSoundSystemLocal::s_constantAmplitude.GetFloat();
 	}
 
-	if (removeStatus > REMOVE_STATUS_WAITSAMPLEFINISHED) {
+	if ( removeStatus > REMOVE_STATUS_WAITSAMPLEFINISHED ) {
 		return 0.0;
 	}
 
 	int localTime = soundSystemLocal.GetCurrent44kHzTime();
 
 	// see if we can use our cached value
-	if (ampTime == localTime) {
+	if ( ampTime == localTime ) {
 		return amplitude;
 	}
 
 	// calculate a new value
 	ampTime = localTime;
-	amplitude = soundWorld->FindAmplitude(this, localTime, NULL, SCHANNEL_ANY, false);
+	amplitude = soundWorld->FindAmplitude( this, localTime, NULL, SCHANNEL_ANY, false );
 
 	return amplitude;
 }
@@ -1204,8 +1102,7 @@ float idSoundEmitterLocal::CurrentAmplitude(void)
 idSoundEmitterLocal::GetSlowChannel
 ===================
 */
-idSlowChannel idSoundEmitterLocal::GetSlowChannel(const idSoundChannel *chan)
-{
+idSlowChannel idSoundEmitterLocal::GetSlowChannel( const idSoundChannel *chan ) {
 	return slowChannels[chan - channels];
 }
 
@@ -1214,8 +1111,7 @@ idSlowChannel idSoundEmitterLocal::GetSlowChannel(cons
 idSoundEmitterLocal::SetSlowChannel
 ===================
 */
-void idSoundEmitterLocal::SetSlowChannel(const idSoundChannel *chan, idSlowChannel slow)
-{
+void idSoundEmitterLocal::SetSlowChannel( const idSoundChannel *chan, idSlowChannel slow ) {
 	slowChannels[chan - channels] = slow;
 }
 
@@ -1224,8 +1120,7 @@ void idSoundEmitterLocal::SetSlowChannel(const idSound
 idSoundEmitterLocal::ResetSlowChannel
 ===================
 */
-void idSoundEmitterLocal::ResetSlowChannel(const idSoundChannel *chan)
-{
+void idSoundEmitterLocal::ResetSlowChannel( const idSoundChannel *chan ) {
 	int index = chan - channels;
 	slowChannels[index].Reset();
 }
@@ -1235,18 +1130,14 @@ void idSoundEmitterLocal::ResetSlowChannel(const idSou
 idSlowChannel::Reset
 ===================
 */
-void idSlowChannel::Reset()
-{
-    // DG: memset() on this is problematic, because lowpass (SoundFX_LowpassFast) has a vtable
-    //memset( this, 0, sizeof( *this ) );
-    active = false;
-    chan = NULL;
-    playbackState = 0;
-    lowpass.Clear();
+void idSlowChannel::Reset() {
+	memset( this, 0, sizeof( *this ) );
 
-	curPosition.Set(0);
-	newPosition.Set(0);
+	this->chan = chan;
 
+	curPosition.Set( 0 );
+	newPosition.Set( 0 );
+
 	curSampleOffset = -10000;
 	newSampleOffset = -10000;
 
@@ -1258,8 +1149,7 @@ void idSlowChannel::Reset()
 idSlowChannel::AttachSoundChannel
 ===================
 */
-void idSlowChannel::AttachSoundChannel(const idSoundChannel *chan)
-{
+void idSlowChannel::AttachSoundChannel( const idSoundChannel *chan ) {
 	this->chan = chan;
 }
 
@@ -1268,11 +1158,10 @@ void idSlowChannel::AttachSoundChannel(const idSoundCh
 idSlowChannel::GetSlowmoSpeed
 ===================
 */
-float idSlowChannel::GetSlowmoSpeed()
-{
-	idSoundWorldLocal *sw = static_cast<idSoundWorldLocal *>(soundSystemLocal.GetPlayingSoundWorld());
+float idSlowChannel::GetSlowmoSpeed() {
+	idSoundWorldLocal *sw = static_cast<idSoundWorldLocal*>( soundSystemLocal.GetPlayingSoundWorld() );
 
-	if (sw) {
+	if ( sw ) {
 		return sw->slowmoSpeed;
 	} else {
 		return 0;
@@ -1284,28 +1173,26 @@ float idSlowChannel::GetSlowmoSpeed()
 idSlowChannel::GenerateSlowChannel
 ===================
 */
-void idSlowChannel::GenerateSlowChannel(FracTime &playPos, int sampleCount44k, float *finalBuffer)
-{
-	idSoundWorldLocal *sw = static_cast<idSoundWorldLocal *>(soundSystemLocal.GetPlayingSoundWorld());
+void idSlowChannel::GenerateSlowChannel( FracTime& playPos, int sampleCount44k, float* finalBuffer ) {
+	idSoundWorldLocal *sw = static_cast<idSoundWorldLocal*>( soundSystemLocal.GetPlayingSoundWorld() );
 	float in[MIXBUFFER_SAMPLES+3], out[MIXBUFFER_SAMPLES+3], *src, *spline, slowmoSpeed;
-	int i, neededSamples, orgTime, zeroedPos, count = 0;
+	int i, neededSamples, zeroedPos, count = 0;
 
 	src = in + 2;
 	spline = out + 2;
 
-	if (sw) {
+	if ( sw ) {
 		slowmoSpeed = sw->slowmoSpeed;
-	} else {
+	}
+	else {
 		slowmoSpeed = 1;
 	}
 
 	neededSamples = sampleCount44k * slowmoSpeed + 4;
-	orgTime = playPos.time;
 
 	// get the channel's samples
-	chan->GatherChannelSamples(playPos.time * 2, neededSamples, src);
-
-	for (i = 0; i < neededSamples >> 1; i++) {
+	chan->GatherChannelSamples( playPos.time * 2, neededSamples, src );
+	for ( i = 0; i < neededSamples >> 1; i++ ) {
 		spline[i] = src[i*2];
 	}
 
@@ -1313,26 +1200,26 @@ void idSlowChannel::GenerateSlowChannel(FracTime &play
 	zeroedPos = playPos.time;
 	playPos.time = 0;
 
-	for (i = 0; i < sampleCount44k >> 1; i++, count += 2) {
+	for ( i = 0; i < sampleCount44k >> 1; i++, count += 2 ) {
 		float val;
 		val = spline[playPos.time];
 		src[i] = val;
-		playPos.Increment(slowmoSpeed);
+		playPos.Increment( slowmoSpeed );
 	}
 
 	// lowpass filter
 	float *in_p = in + 2, *out_p = out + 2;
 	int numSamples = sampleCount44k >> 1;
 
-	lowpass.GetContinuitySamples(in_p[-1], in_p[-2], out_p[-1], out_p[-2]);
-	lowpass.SetParms(slowmoSpeed * 15000, 1.2f);
+	lowpass.GetContinuitySamples( in_p[-1], in_p[-2], out_p[-1], out_p[-2] );
+	lowpass.SetParms( slowmoSpeed * 15000, 1.2f );
 
-	for (int i = 0, count = 0; i < numSamples; i++, count += 2) {
-		lowpass.ProcessSample(in_p + i, out_p + i);
+	for ( int i = 0, count = 0; i < numSamples; i++, count += 2 ) {
+		lowpass.ProcessSample( in_p + i, out_p + i );
 		finalBuffer[count] = finalBuffer[count+1] = out[i];
 	}
 
-	lowpass.SetContinuitySamples(in_p[numSamples-2], in_p[numSamples-3], out_p[numSamples-2], out_p[numSamples-3]);
+	lowpass.SetContinuitySamples( in_p[numSamples-2], in_p[numSamples-3], out_p[numSamples-2], out_p[numSamples-3] );
 
 	playPos.time += zeroedPos;
 }
@@ -1342,8 +1229,7 @@ void idSlowChannel::GenerateSlowChannel(FracTime &play
 idSlowChannel::GatherChannelSamples
 ===================
 */
-void idSlowChannel::GatherChannelSamples(int sampleOffset44k, int sampleCount44k, float *dest)
-{
+void idSlowChannel::GatherChannelSamples( int sampleOffset44k, int sampleCount44k, float *dest ) {
 	int state = 0;
 
 	// setup chan
@@ -1351,14 +1237,14 @@ void idSlowChannel::GatherChannelSamples(int sampleOff
 	newSampleOffset = sampleOffset44k >> 1;
 
 	// set state
-	if (newSampleOffset < curSampleOffset) {
+	if ( newSampleOffset < curSampleOffset ) {
 		state = PLAYBACK_RESET;
-	} else if (newSampleOffset > curSampleOffset) {
+	} else if ( newSampleOffset > curSampleOffset ) {
 		state = PLAYBACK_ADVANCING;
 	}
 
-	if (state == PLAYBACK_RESET) {
-		curPosition.Set(newSampleOffset);
+	if ( state == PLAYBACK_RESET ) {
+		curPosition.Set( newSampleOffset );
 	}
 
 	// set current vars
@@ -1366,13 +1252,12 @@ void idSlowChannel::GatherChannelSamples(int sampleOff
 	newPosition = curPosition;
 
 	// do the slow processing
-	GenerateSlowChannel(newPosition, sampleCount44k, dest);
+	GenerateSlowChannel( newPosition, sampleCount44k, dest );
 
 	// finish off
-	if (state == PLAYBACK_ADVANCING)
+	if ( state == PLAYBACK_ADVANCING )
 		curPosition = newPosition;
 }
-
 #ifdef _HUMANHEAD
 soundShaderParms_t* idSoundEmitterLocal::GetSoundParms(idSoundShader* shader, const s_channelType channel)
 {
@@ -1388,5 +1273,4 @@ void idSoundEmitterLocal::ModifySound(idSoundShader* s
 	if(chan)
 	parmModifier.ModifyParms(chan->parms);
 }
-#endif
-
+#endif
\ No newline at end of file
