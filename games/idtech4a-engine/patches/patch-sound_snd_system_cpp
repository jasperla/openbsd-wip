Index: sound/snd_system.cpp
--- sound/snd_system.cpp.orig
+++ sound/snd_system.cpp
@@ -4,7 +4,7 @@
 Doom 3 GPL Source Code
 Copyright (C) 1999-2011 id Software LLC, a ZeniMax Media company.
 
-This file is part of the Doom 3 GPL Source Code (?Doom 3 Source Code?).
+This file is part of the Doom 3 GPL Source Code ("Doom 3 Source Code").
 
 Doom 3 Source Code is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -30,74 +30,60 @@ If you have questions concerning this license or the a
 #pragma hdrstop
 
 #include "snd_local.h"
-#include "sound.h"
 
 #ifdef ID_DEDICATED
-idCVar idSoundSystemLocal::s_noSound("s_noSound", "1", CVAR_SOUND | CVAR_BOOL | CVAR_ROM, "");
+idCVar idSoundSystemLocal::s_noSound( "s_noSound", "1", CVAR_SOUND | CVAR_BOOL | CVAR_ROM, "" );
 #else
-idCVar idSoundSystemLocal::s_noSound("s_noSound", "0", CVAR_SOUND | CVAR_BOOL | CVAR_NOCHEAT, "");
+idCVar idSoundSystemLocal::s_noSound( "s_noSound", "0", CVAR_SOUND | CVAR_BOOL | CVAR_NOCHEAT, "" );
 #endif
-idCVar idSoundSystemLocal::s_quadraticFalloff("s_quadraticFalloff", "1", CVAR_SOUND | CVAR_BOOL, "");
-idCVar idSoundSystemLocal::s_drawSounds("s_drawSounds", "0", CVAR_SOUND | CVAR_INTEGER, "", 0, 2, idCmdSystem::ArgCompletion_Integer<0,2>);
-idCVar idSoundSystemLocal::s_showStartSound("s_showStartSound", "0", CVAR_SOUND | CVAR_BOOL, "");
-idCVar idSoundSystemLocal::s_useOcclusion("s_useOcclusion", "1", CVAR_SOUND | CVAR_BOOL, "");
-idCVar idSoundSystemLocal::s_maxSoundsPerShader("s_maxSoundsPerShader", "0", CVAR_SOUND | CVAR_ARCHIVE, "", 0, 10, idCmdSystem::ArgCompletion_Integer<0,10>);
-idCVar idSoundSystemLocal::s_showLevelMeter("s_showLevelMeter", "0", CVAR_SOUND | CVAR_BOOL, "");
-idCVar idSoundSystemLocal::s_constantAmplitude("s_constantAmplitude", "-1", CVAR_SOUND | CVAR_FLOAT, "");
-idCVar idSoundSystemLocal::s_minVolume6("s_minVolume6", "0", CVAR_SOUND | CVAR_FLOAT, "");
-idCVar idSoundSystemLocal::s_dotbias6("s_dotbias6", "0.8", CVAR_SOUND | CVAR_FLOAT, "");
-idCVar idSoundSystemLocal::s_minVolume2("s_minVolume2", "0.25", CVAR_SOUND | CVAR_FLOAT, "");
-idCVar idSoundSystemLocal::s_dotbias2("s_dotbias2", "1.1", CVAR_SOUND | CVAR_FLOAT, "");
-idCVar idSoundSystemLocal::s_spatializationDecay("s_spatializationDecay", "2", CVAR_SOUND | CVAR_ARCHIVE | CVAR_FLOAT, "");
-idCVar idSoundSystemLocal::s_reverse("s_reverse", "0", CVAR_SOUND | CVAR_ARCHIVE | CVAR_BOOL, "");
-idCVar idSoundSystemLocal::s_meterTopTime("s_meterTopTime", "2000", CVAR_SOUND | CVAR_ARCHIVE | CVAR_INTEGER, "");
-idCVar idSoundSystemLocal::s_volume("s_volume_dB", "0", CVAR_SOUND | CVAR_ARCHIVE | CVAR_FLOAT, "volume in dB");
-idCVar idSoundSystemLocal::s_playDefaultSound("s_playDefaultSound", "1", CVAR_SOUND | CVAR_ARCHIVE | CVAR_BOOL, "play a beep for missing sounds");
-idCVar idSoundSystemLocal::s_subFraction("s_subFraction", "0.75", CVAR_SOUND | CVAR_ARCHIVE | CVAR_FLOAT, "volume to subwoofer in 5.1");
-idCVar idSoundSystemLocal::s_globalFraction("s_globalFraction", "0.8", CVAR_SOUND | CVAR_ARCHIVE | CVAR_FLOAT, "volume to all speakers when not spatialized");
-idCVar idSoundSystemLocal::s_doorDistanceAdd("s_doorDistanceAdd", "150", CVAR_SOUND | CVAR_ARCHIVE | CVAR_FLOAT, "reduce sound volume with this distance when going through a door");
-idCVar idSoundSystemLocal::s_singleEmitter("s_singleEmitter", "0", CVAR_SOUND | CVAR_INTEGER, "mute all sounds but this emitter");
-idCVar idSoundSystemLocal::s_numberOfSpeakers("s_numberOfSpeakers", "2", CVAR_SOUND | CVAR_ARCHIVE, "number of speakers");
-idCVar idSoundSystemLocal::s_force22kHz("s_force22kHz", "0", CVAR_SOUND | CVAR_BOOL, "");
-idCVar idSoundSystemLocal::s_clipVolumes("s_clipVolumes", "1", CVAR_SOUND | CVAR_BOOL, "");
-idCVar idSoundSystemLocal::s_realTimeDecoding("s_realTimeDecoding", "1", CVAR_SOUND | CVAR_BOOL | CVAR_INIT, "");
+idCVar idSoundSystemLocal::s_quadraticFalloff( "s_quadraticFalloff", "1", CVAR_SOUND | CVAR_BOOL, "" );
+idCVar idSoundSystemLocal::s_drawSounds( "s_drawSounds", "0", CVAR_SOUND | CVAR_INTEGER, "", 0, 2, idCmdSystem::ArgCompletion_Integer<0,2> );
+idCVar idSoundSystemLocal::s_showStartSound( "s_showStartSound", "0", CVAR_SOUND | CVAR_BOOL, "" );
+idCVar idSoundSystemLocal::s_useOcclusion( "s_useOcclusion", "1", CVAR_SOUND | CVAR_BOOL, "" );
+idCVar idSoundSystemLocal::s_maxSoundsPerShader( "s_maxSoundsPerShader", "0", CVAR_SOUND | CVAR_ARCHIVE, "", 0, 10, idCmdSystem::ArgCompletion_Integer<0,10> );
+idCVar idSoundSystemLocal::s_showLevelMeter( "s_showLevelMeter", "0", CVAR_SOUND | CVAR_BOOL, "" );
+idCVar idSoundSystemLocal::s_constantAmplitude( "s_constantAmplitude", "-1", CVAR_SOUND | CVAR_FLOAT, "" );
+idCVar idSoundSystemLocal::s_minVolume6( "s_minVolume6", "0", CVAR_SOUND | CVAR_FLOAT, "" );
+idCVar idSoundSystemLocal::s_dotbias6( "s_dotbias6", "0.8", CVAR_SOUND | CVAR_FLOAT, "" );
+idCVar idSoundSystemLocal::s_minVolume2( "s_minVolume2", "0.25", CVAR_SOUND | CVAR_FLOAT, "" );
+idCVar idSoundSystemLocal::s_dotbias2( "s_dotbias2", "1.1", CVAR_SOUND | CVAR_FLOAT, "" );
+idCVar idSoundSystemLocal::s_spatializationDecay( "s_spatializationDecay", "2", CVAR_SOUND | CVAR_ARCHIVE | CVAR_FLOAT, "" );
+idCVar idSoundSystemLocal::s_reverse( "s_reverse", "0", CVAR_SOUND | CVAR_ARCHIVE | CVAR_BOOL, "" );
+idCVar idSoundSystemLocal::s_meterTopTime( "s_meterTopTime", "2000", CVAR_SOUND | CVAR_ARCHIVE | CVAR_INTEGER, "" );
+idCVar idSoundSystemLocal::s_volume( "s_volume_dB", "0", CVAR_SOUND | CVAR_ARCHIVE | CVAR_FLOAT, "volume in dB" );
+idCVar idSoundSystemLocal::s_playDefaultSound( "s_playDefaultSound", "1", CVAR_SOUND | CVAR_ARCHIVE | CVAR_BOOL, "play a beep for missing sounds" );
+idCVar idSoundSystemLocal::s_subFraction( "s_subFraction", "0.75", CVAR_SOUND | CVAR_ARCHIVE | CVAR_FLOAT, "volume to subwoofer in 5.1" );
+idCVar idSoundSystemLocal::s_globalFraction( "s_globalFraction", "0.8", CVAR_SOUND | CVAR_ARCHIVE | CVAR_FLOAT, "volume to all speakers when not spatialized" );
+idCVar idSoundSystemLocal::s_doorDistanceAdd( "s_doorDistanceAdd", "150", CVAR_SOUND | CVAR_ARCHIVE | CVAR_FLOAT, "reduce sound volume with this distance when going through a door" );
+idCVar idSoundSystemLocal::s_singleEmitter( "s_singleEmitter", "0", CVAR_SOUND | CVAR_INTEGER, "mute all sounds but this emitter" );
+idCVar idSoundSystemLocal::s_numberOfSpeakers( "s_numberOfSpeakers", "2", CVAR_SOUND | CVAR_ARCHIVE, "number of speakers" );
+idCVar idSoundSystemLocal::s_force22kHz( "s_force22kHz", "0", CVAR_SOUND | CVAR_BOOL, ""  );
+idCVar idSoundSystemLocal::s_clipVolumes( "s_clipVolumes", "1", CVAR_SOUND | CVAR_BOOL, ""  );
+idCVar idSoundSystemLocal::s_realTimeDecoding( "s_realTimeDecoding", "1", CVAR_SOUND | CVAR_BOOL | CVAR_INIT, "" );
 
-idCVar idSoundSystemLocal::s_slowAttenuate("s_slowAttenuate", "1", CVAR_SOUND | CVAR_BOOL, "slowmo sounds attenuate over shorted distance");
-idCVar idSoundSystemLocal::s_enviroSuitCutoffFreq("s_enviroSuitCutoffFreq", "2000", CVAR_SOUND | CVAR_FLOAT, "");
-idCVar idSoundSystemLocal::s_enviroSuitCutoffQ("s_enviroSuitCutoffQ", "2", CVAR_SOUND | CVAR_FLOAT, "");
-idCVar idSoundSystemLocal::s_reverbTime("s_reverbTime", "1000", CVAR_SOUND | CVAR_FLOAT, "");
-idCVar idSoundSystemLocal::s_reverbFeedback("s_reverbFeedback", "0.333", CVAR_SOUND | CVAR_FLOAT, "");
-idCVar idSoundSystemLocal::s_enviroSuitVolumeScale("s_enviroSuitVolumeScale", "0.9", CVAR_SOUND | CVAR_FLOAT, "");
-idCVar idSoundSystemLocal::s_skipHelltimeFX("s_skipHelltimeFX", "0", CVAR_SOUND | CVAR_BOOL, "");
+idCVar idSoundSystemLocal::s_slowAttenuate( "s_slowAttenuate", "1", CVAR_SOUND | CVAR_BOOL, "slowmo sounds attenuate over shorted distance" );
+idCVar idSoundSystemLocal::s_enviroSuitCutoffFreq( "s_enviroSuitCutoffFreq", "2000", CVAR_SOUND | CVAR_FLOAT, "" );
+idCVar idSoundSystemLocal::s_enviroSuitCutoffQ( "s_enviroSuitCutoffQ", "2", CVAR_SOUND | CVAR_FLOAT, "" );
+idCVar idSoundSystemLocal::s_reverbTime( "s_reverbTime", "1000", CVAR_SOUND | CVAR_FLOAT, "" );
+idCVar idSoundSystemLocal::s_reverbFeedback( "s_reverbFeedback", "0.333", CVAR_SOUND | CVAR_FLOAT, "" );
+idCVar idSoundSystemLocal::s_enviroSuitVolumeScale( "s_enviroSuitVolumeScale", "0.9", CVAR_SOUND | CVAR_FLOAT, "" );
+idCVar idSoundSystemLocal::s_skipHelltimeFX( "s_skipHelltimeFX", "0", CVAR_SOUND | CVAR_BOOL, "" );
 
 #if ID_OPENAL
 // off by default. OpenAL DLL gets loaded on-demand
-#ifdef _WIN32
-idCVar idSoundSystemLocal::s_libOpenAL("s_libOpenAL", "openal32.dll", CVAR_SOUND | CVAR_ARCHIVE, "OpenAL DLL name/path");
+idCVar idSoundSystemLocal::s_libOpenAL( "s_libOpenAL", "openal32.dll", CVAR_SOUND | CVAR_ARCHIVE, "Deprecated, kept for compability" );
+idCVar idSoundSystemLocal::s_useOpenAL( "s_useOpenAL", "0", CVAR_SOUND | CVAR_BOOL | CVAR_ARCHIVE, "Deprecated, kept for compability" );
+idCVar idSoundSystemLocal::s_useEAXReverb( "s_useEAXReverb", "0", CVAR_SOUND | CVAR_BOOL | CVAR_ARCHIVE, "use EAX reverb" );
+idCVar idSoundSystemLocal::s_muteEAXReverb( "s_muteEAXReverb", "0", CVAR_SOUND | CVAR_BOOL, "mute eax reverb" );
+idCVar idSoundSystemLocal::s_decompressionLimit( "s_decompressionLimit", "6", CVAR_SOUND | CVAR_INTEGER | CVAR_ARCHIVE, "specifies maximum uncompressed sample length in seconds" );
 #else
-idCVar idSoundSystemLocal::s_libOpenAL("s_libOpenAL", "./libopenal.so", CVAR_SOUND | CVAR_ARCHIVE, "OpenAL DLL name/path");
+idCVar idSoundSystemLocal::s_libOpenAL( "s_libOpenAL", "openal32.dll", CVAR_SOUND | CVAR_ARCHIVE, "OpenAL is not supported in this build" );
+idCVar idSoundSystemLocal::s_useOpenAL( "s_useOpenAL", "0", CVAR_SOUND | CVAR_BOOL | CVAR_ROM, "OpenAL is not supported in this build" );
+idCVar idSoundSystemLocal::s_useEAXReverb( "s_useEAXReverb", "0", CVAR_SOUND | CVAR_BOOL | CVAR_ROM, "EAX not available in this build" );
+idCVar idSoundSystemLocal::s_muteEAXReverb( "s_muteEAXReverb", "0", CVAR_SOUND | CVAR_BOOL | CVAR_ROM, "mute eax reverb" );
+idCVar idSoundSystemLocal::s_decompressionLimit( "s_decompressionLimit", "6", CVAR_SOUND | CVAR_INTEGER | CVAR_ROM, "specifies maximum uncompressed sample length in seconds" );
 #endif
-#ifdef _WIN32 //karin: enable OpenAL default on Windows
-idCVar idSoundSystemLocal::s_useOpenAL("s_useOpenAL", "1", CVAR_SOUND | CVAR_BOOL | CVAR_ARCHIVE, "use OpenAL");
-idCVar idSoundSystemLocal::s_useEAXReverb("s_useEAXReverb", "1", CVAR_SOUND | CVAR_BOOL | CVAR_ARCHIVE, "use EAX reverb");
-#else
-idCVar idSoundSystemLocal::s_useOpenAL("s_useOpenAL", "0", CVAR_SOUND | CVAR_BOOL | CVAR_ARCHIVE, "use OpenAL");
-idCVar idSoundSystemLocal::s_useEAXReverb("s_useEAXReverb", "0", CVAR_SOUND | CVAR_BOOL | CVAR_ARCHIVE, "use EAX reverb");
-#endif
-idCVar idSoundSystemLocal::s_muteEAXReverb("s_muteEAXReverb", "0", CVAR_SOUND | CVAR_BOOL, "mute eax reverb");
-idCVar idSoundSystemLocal::s_decompressionLimit("s_decompressionLimit", "6", CVAR_SOUND | CVAR_INTEGER | CVAR_ARCHIVE, "specifies maximum uncompressed sample length in seconds");
-#else
-idCVar idSoundSystemLocal::s_libOpenAL("s_libOpenAL", "openal32.dll", CVAR_SOUND | CVAR_ROM, "OpenAL is not supported in this build");
-idCVar idSoundSystemLocal::s_useOpenAL("s_useOpenAL", "0", CVAR_SOUND | CVAR_BOOL | CVAR_ROM, "OpenAL is not supported in this build");
-idCVar idSoundSystemLocal::s_useEAXReverb("s_useEAXReverb", "0", CVAR_SOUND | CVAR_BOOL | CVAR_ROM, "EAX not available in this build");
-idCVar idSoundSystemLocal::s_muteEAXReverb("s_muteEAXReverb", "0", CVAR_SOUND | CVAR_BOOL | CVAR_ROM, "mute eax reverb");
-idCVar idSoundSystemLocal::s_decompressionLimit("s_decompressionLimit", "6", CVAR_SOUND | CVAR_INTEGER | CVAR_ROM, "specifies maximum uncompressed sample length in seconds");
-#endif
-#ifdef _OPENAL_EFX
-idCVar idSoundSystemLocal::s_alReverbGain( "s_alReverbGain", "0.5", CVAR_SOUND | CVAR_FLOAT | CVAR_ARCHIVE, "reduce reverb strength (0.0 to 1.0)", 0.0f, 1.0f );
-#endif
 
-bool idSoundSystemLocal::useOpenAL = false;
 bool idSoundSystemLocal::useEAXReverb = false;
 int idSoundSystemLocal::EAXAvailable = -1;
 
@@ -111,22 +97,18 @@ SoundReloadSounds_f
   this is called from the main thread
 ===============
 */
-void SoundReloadSounds_f(const idCmdArgs &args)
-{
-	if (!soundSystemLocal.soundCache) {
+void SoundReloadSounds_f( const idCmdArgs &args ) {
+	if ( !soundSystemLocal.soundCache ) {
 		return;
 	}
-
 	bool force = false;
-
-	if (args.Argc() == 2) {
+	if ( args.Argc() == 2 ) {
 		force = true;
 	}
-
-	soundSystem->SetMute(true);
-	soundSystemLocal.soundCache->ReloadSounds(force);
-	soundSystem->SetMute(false);
-	common->Printf("sound: changed sounds reloaded\n");
+	soundSystem->SetMute( true );
+	soundSystemLocal.soundCache->ReloadSounds( force );
+	soundSystem->SetMute( false );
+	common->Printf( "sound: changed sounds reloaded\n" );
 }
 
 /*
@@ -136,13 +118,12 @@ ListSounds_f
 Optional parameter to only list sounds containing that string
 ===============
 */
-void ListSounds_f(const idCmdArgs &args)
-{
+void ListSounds_f( const idCmdArgs &args ) {
 	int i;
-	const char	*snd = args.Argv(1);
+	const char	*snd = args.Argv( 1 );
 
-	if (!soundSystemLocal.soundCache) {
-		common->Printf("No sound.\n");
+	if ( !soundSystemLocal.soundCache ) {
+		common->Printf( "No sound.\n" );
 		return;
 	}
 
@@ -150,48 +131,39 @@ void ListSounds_f(const idCmdArgs &args)
 	int totalSamples = 0;
 	int totalMemory = 0;
 	int totalPCMMemory = 0;
-
-	for (i = 0; i < soundSystemLocal.soundCache->GetNumObjects(); i++) {
+	for( i = 0; i < soundSystemLocal.soundCache->GetNumObjects(); i++ ) {
 		const idSoundSample *sample = soundSystemLocal.soundCache->GetObject(i);
-
-		if (!sample) {
+		if ( !sample ) {
 			continue;
 		}
-
-		if (snd && sample->name.Find(snd, false) < 0) {
+		if ( snd && sample->name.Find( snd, false ) < 0 ) {
 			continue;
 		}
 
 		const waveformatex_t &info = sample->objectInfo;
 
-		const char *stereo = (info.nChannels == 2 ? "ST" : "  ");
+		const char *stereo = ( info.nChannels == 2 ? "ST" : "  " );
+		const char *format = ( info.wFormatTag == WAVE_FORMAT_TAG_OGG ) ? "OGG" : "WAV";
+		const char *defaulted = ( sample->defaultSound ? "(DEFAULTED)" : sample->purged ? "(PURGED)" : "" );
 
-		const char *format = (info.wFormatTag == WAVE_FORMAT_TAG_OGG) ? "OGG" : "WAV";
+		common->Printf( "%s %dkHz %6dms %5dkB %4s %s%s\n", stereo, sample->objectInfo.nSamplesPerSec / 1000,
+					soundSystemLocal.SamplesToMilliseconds( sample->LengthIn44kHzSamples() ),
+					sample->objectMemSize >> 10, format, sample->name.c_str(), defaulted );
 
-		const char *defaulted = (sample->defaultSound ? "(DEFAULTED)" : sample->purged ? "(PURGED)" : "");
-
-		common->Printf("%s %dkHz %6dms %5dkB %4s %s%s\n", stereo, sample->objectInfo.nSamplesPerSec / 1000,
-		               soundSystemLocal.SamplesToMilliseconds(sample->LengthIn44kHzSamples()),
-		               sample->objectMemSize >> 10, format, sample->name.c_str(), defaulted);
-
-		if (!sample->purged) {
+		if ( !sample->purged ) {
 			totalSamples += sample->objectSize;
-
-			if (info.wFormatTag != WAVE_FORMAT_TAG_OGG)
+			if ( info.wFormatTag != WAVE_FORMAT_TAG_OGG )
 				totalPCMMemory += sample->objectMemSize;
-
-			if (!sample->hardwareBuffer)
+			if ( !sample->hardwareBuffer )
 				totalMemory += sample->objectMemSize;
 		}
-
 		totalSounds++;
 	}
-
-	common->Printf("%8d total sounds\n", totalSounds);
-	common->Printf("%8d total samples loaded\n", totalSamples);
-	common->Printf("%8d kB total system memory used\n", totalMemory >> 10);
+	common->Printf( "%8d total sounds\n", totalSounds );
+	common->Printf( "%8d total samples loaded\n", totalSamples );
+	common->Printf( "%8d kB total system memory used\n", totalMemory >> 10 );
 #if ID_OPENAL
-	common->Printf("%8d kB total OpenAL audio memory used\n", (alGetInteger(alGetEnumValue((ALubyte *)"AL_EAX_RAM_SIZE")) - alGetInteger(alGetEnumValue((ALubyte *)"AL_EAX_RAM_FREE"))) >> 10);
+	common->Printf( "%8d kB total OpenAL audio memory used\n", ( alGetInteger( alGetEnumValue( "AL_EAX_RAM_SIZE" ) ) - alGetInteger( alGetEnumValue( "AL_EAX_RAM_FREE" ) ) ) >> 10 );
 #endif
 }
 
@@ -200,74 +172,69 @@ void ListSounds_f(const idCmdArgs &args)
 ListSoundDecoders_f
 ===============
 */
-void ListSoundDecoders_f(const idCmdArgs &args)
-{
+void ListSoundDecoders_f( const idCmdArgs &args ) {
 	int i, j, numActiveDecoders, numWaitingDecoders;
 	idSoundWorldLocal *sw = soundSystemLocal.currentSoundWorld;
 
 	numActiveDecoders = numWaitingDecoders = 0;
 
-	for (i = 0; i < sw->emitters.Num(); i++) {
+	for ( i = 0; i < sw->emitters.Num(); i++ ) {
 		idSoundEmitterLocal *sound = sw->emitters[i];
 
-		if (!sound) {
+		if ( !sound ) {
 			continue;
 		}
 
 		// run through all the channels
-		for (j = 0; j < SOUND_MAX_CHANNELS; j++) {
+		for ( j = 0; j < SOUND_MAX_CHANNELS; j++ ) {
 			idSoundChannel	*chan = &sound->channels[j];
 
-			if (chan->decoder == NULL) {
+			if ( chan->decoder == NULL ) {
 				continue;
 			}
 
 			idSoundSample *sample = chan->decoder->GetSample();
 
-			if (sample != NULL) {
+			if ( sample != NULL ) {
 				continue;
 			}
 
-			const char *format = (chan->leadinSample->objectInfo.wFormatTag == WAVE_FORMAT_TAG_OGG) ? "OGG" : "WAV";
+			const char *format = ( chan->leadinSample->objectInfo.wFormatTag == WAVE_FORMAT_TAG_OGG ) ? "OGG" : "WAV";
+			common->Printf( "%3d waiting %s: %s\n", numWaitingDecoders, format, chan->leadinSample->name.c_str() );
 
-			common->Printf("%3d waiting %s: %s\n", numWaitingDecoders, format, chan->leadinSample->name.c_str());
-
 			numWaitingDecoders++;
 		}
 	}
 
-	for (i = 0; i < sw->emitters.Num(); i++) {
+	for ( i = 0; i < sw->emitters.Num(); i++ ) {
 		idSoundEmitterLocal *sound = sw->emitters[i];
 
-		if (!sound) {
+		if ( !sound ) {
 			continue;
 		}
 
 		// run through all the channels
-		for (j = 0; j < SOUND_MAX_CHANNELS; j++) {
+		for ( j = 0; j < SOUND_MAX_CHANNELS; j++ ) {
 			idSoundChannel	*chan = &sound->channels[j];
 
-			if (chan->decoder == NULL) {
+			if ( chan->decoder == NULL ) {
 				continue;
 			}
 
 			idSoundSample *sample = chan->decoder->GetSample();
 
-			if (sample == NULL) {
+			if ( sample == NULL ) {
 				continue;
 			}
 
-			const char *format = (sample->objectInfo.wFormatTag == WAVE_FORMAT_TAG_OGG) ? "OGG" : "WAV";
+			const char *format = ( sample->objectInfo.wFormatTag == WAVE_FORMAT_TAG_OGG ) ? "OGG" : "WAV";
 
 			int localTime = soundSystemLocal.GetCurrent44kHzTime() - chan->trigger44kHzTime;
-
 			int sampleTime = sample->LengthIn44kHzSamples() * sample->objectInfo.nChannels;
-
 			int percent;
-
-			if (localTime > sampleTime) {
-				if (chan->parms.soundShaderFlags & SSF_LOOPING) {
-					percent = (localTime % sampleTime) * 100 / sampleTime;
+			if ( localTime > sampleTime ) {
+				if ( chan->parms.soundShaderFlags & SSF_LOOPING ) {
+					percent = ( localTime % sampleTime ) * 100 / sampleTime;
 				} else {
 					percent = 100;
 				}
@@ -275,16 +242,16 @@ void ListSoundDecoders_f(const idCmdArgs &args)
 				percent = localTime * 100 / sampleTime;
 			}
 
-			common->Printf("%3d decoding %3d%% %s: %s\n", numActiveDecoders, percent, format, sample->name.c_str());
+			common->Printf( "%3d decoding %3d%% %s: %s\n", numActiveDecoders, percent, format, sample->name.c_str() );
 
 			numActiveDecoders++;
 		}
 	}
 
-	common->Printf("%d decoders\n", numWaitingDecoders + numActiveDecoders);
-	common->Printf("%d waiting decoders\n", numWaitingDecoders);
-	common->Printf("%d active decoders\n", numActiveDecoders);
-	common->Printf("%d kB decoder memory in %d blocks\n", idSampleDecoder::GetUsedBlockMemory() >> 10, idSampleDecoder::GetNumUsedBlocks());
+	common->Printf( "%d decoders\n", numWaitingDecoders + numActiveDecoders );
+	common->Printf( "%d waiting decoders\n", numWaitingDecoders );
+	common->Printf( "%d active decoders\n", numActiveDecoders );
+	common->Printf( "%d kB decoder memory in %d blocks\n", idSampleDecoder::GetUsedBlockMemory() >> 10, idSampleDecoder::GetNumUsedBlocks() );
 }
 
 /*
@@ -294,15 +261,13 @@ TestSound_f
   this is called from the main thread
 ===============
 */
-void TestSound_f(const idCmdArgs &args)
-{
-	if (args.Argc() != 2) {
-		common->Printf("Usage: testSound <file>\n");
+void TestSound_f( const idCmdArgs &args ) {
+	if ( args.Argc() != 2 ) {
+		common->Printf( "Usage: testSound <file>\n" );
 		return;
 	}
-
-	if (soundSystemLocal.currentSoundWorld) {
-		soundSystemLocal.currentSoundWorld->PlayShaderDirectly(args.Argv(1));
+	if ( soundSystemLocal.currentSoundWorld ) {
+		soundSystemLocal.currentSoundWorld->PlayShaderDirectly( args.Argv( 1 ) );
 	}
 }
 
@@ -315,12 +280,11 @@ restart the sound thread
   this is called from the main thread
 ===============
 */
-void SoundSystemRestart_f(const idCmdArgs &args)
-{
-	soundSystem->SetMute(true);
+void SoundSystemRestart_f( const idCmdArgs &args ) {
+	soundSystem->SetMute( true );
 	soundSystemLocal.ShutdownHW();
 	soundSystemLocal.InitHW();
-	soundSystem->SetMute(false);
+	soundSystem->SetMute( false );
 }
 
 #ifdef _HUMANHEAD
@@ -374,10 +338,9 @@ idSoundSystemLocal::Init
 initialize the sound system
 ===============
 */
-void idSoundSystemLocal::Init()
-{
+void idSoundSystemLocal::Init() {
 
-	common->Printf("----- Initializing Sound System ------\n");
+	common->Printf( "----- Initializing Sound System ------\n" );
 
 	isInitialized = false;
 	muted = false;
@@ -392,192 +355,104 @@ void idSoundSystemLocal::Init()
 
 	nextWriteBlock = 0xffffffff;
 
-	memset(meterTops, 0, sizeof(meterTops));
-	memset(meterTopsTime, 0, sizeof(meterTopsTime));
+	memset( meterTops, 0, sizeof( meterTops ) );
+	memset( meterTopsTime, 0, sizeof( meterTopsTime ) );
 
-	for (int i = -600; i < 600; i++) {
+	for( int i = -600; i < 600; i++ ) {
 		float pt = i * 0.1f;
-		volumesDB[i+600] = pow(2.0f,(pt * (1.0f / 6.0f)));
+		volumesDB[i+600] = pow( 2.0f,( pt * ( 1.0f / 6.0f ) ) );
 	}
 
 	// make a 16 byte aligned finalMixBuffer
-	finalMixBuffer = (float *)((((intptr_t)realAccum) + 15) & ~15);
+	finalMixBuffer = (float *) ( ( ( (intptr_t)realAccum ) + 15 ) & ~15 );
 
 	graph = NULL;
 
-	if (!s_noSound.GetBool()) {
+	if ( !s_noSound.GetBool() ) {
 		idSampleDecoder::Init();
 		soundCache = new idSoundCache();
 	}
 
 	// set up openal device and context
-#if !defined(_OPENAL_SOFT)
-	common->StartupVariable("s_useOpenAL", true);
-	common->StartupVariable("s_useEAXReverb", true);
-#endif
+	common->StartupVariable( "s_useOpenAL", true );
+	common->StartupVariable( "s_useEAXReverb", true );
 
-#ifdef _OPENAL
-	if (idSoundSystemLocal::s_useOpenAL.GetBool() || idSoundSystemLocal::s_useEAXReverb.GetBool()) {
-		// default all true
-#ifdef _OPENAL_SOFT
-		idSoundSystemLocal::s_useOpenAL.SetBool(true);
-#endif
-		if (!Sys_LoadOpenAL()) {
-			idSoundSystemLocal::s_useOpenAL.SetBool(false);
-            idSoundSystemLocal::s_useEAXReverb.SetBool(false);
-#ifdef _OPENAL_SOFT
-			EAXAvailable = 0;
-#endif
-		} else {
-			common->Printf("Setup OpenAL device and context... ");
-			openalDevice = alcOpenDevice(NULL);
-			openalContext = alcCreateContext(openalDevice, NULL);
-			alcMakeContextCurrent(openalContext);
-			common->Printf("Done.\n");
+	common->Printf( "Setup OpenAL device and context... " );
+	openalDevice = alcOpenDevice( NULL );
+	openalContext = alcCreateContext( openalDevice, NULL );
+	alcMakeContextCurrent( openalContext );
+	common->Printf( "Done.\n" );
 
-			// log openal info
-			common->Printf( "OpenAL vendor: %s\n", alGetString(AL_VENDOR) );
-			common->Printf( "OpenAL renderer: %s\n", alGetString(AL_RENDERER) );
-			common->Printf( "OpenAL version: %s\n", alGetString(AL_VERSION) );
-
-#ifdef _OPENAL_EFX
-			// try to obtain EFX extensions
-			if(idSoundSystemLocal::s_useEAXReverb.GetBool())
-			{
-				if (alcIsExtensionPresent(openalDevice, "ALC_EXT_EFX")) {
-					common->Printf( "OpenAL: found EFX extension\n" );
-					EAXAvailable = 1;
-					idSoundSystemLocal::s_useEAXReverb.SetBool( true );
-
-					alGenEffects = (LPALGENEFFECTS)alGetProcAddress(ID_ALCHAR "alGenEffects");
-					alDeleteEffects = (LPALDELETEEFFECTS)alGetProcAddress(ID_ALCHAR "alDeleteEffects");
-					alIsEffect = (LPALISEFFECT)alGetProcAddress(ID_ALCHAR "alIsEffect");
-					alEffecti = (LPALEFFECTI)alGetProcAddress(ID_ALCHAR "alEffecti");
-					alEffectf = (LPALEFFECTF)alGetProcAddress(ID_ALCHAR "alEffectf");
-					alEffectfv = (LPALEFFECTFV)alGetProcAddress(ID_ALCHAR "alEffectfv");
-					alGenFilters = (LPALGENFILTERS)alGetProcAddress(ID_ALCHAR "alGenFilters");
-					alDeleteFilters = (LPALDELETEFILTERS)alGetProcAddress(ID_ALCHAR "alDeleteFilters");
-					alIsFilter = (LPALISFILTER)alGetProcAddress(ID_ALCHAR "alIsFilter");
-					alFilteri = (LPALFILTERI)alGetProcAddress(ID_ALCHAR "alFilteri");
-					alFilterf = (LPALFILTERF)alGetProcAddress(ID_ALCHAR "alFilterf");
-					alGenAuxiliaryEffectSlots = (LPALGENAUXILIARYEFFECTSLOTS)alGetProcAddress(ID_ALCHAR "alGenAuxiliaryEffectSlots");
-					alDeleteAuxiliaryEffectSlots = (LPALDELETEAUXILIARYEFFECTSLOTS)alGetProcAddress(ID_ALCHAR "alDeleteAuxiliaryEffectSlots");
-					alIsAuxiliaryEffectSlot = (LPALISAUXILIARYEFFECTSLOT)alGetProcAddress(ID_ALCHAR "alIsAuxiliaryEffectSlot");;
-					alAuxiliaryEffectSloti = (LPALAUXILIARYEFFECTSLOTI)alGetProcAddress(ID_ALCHAR "alAuxiliaryEffectSloti");
-					alAuxiliaryEffectSlotf = (LPALAUXILIARYEFFECTSLOTF)alGetProcAddress(ID_ALCHAR "alAuxiliaryEffectSlotf");
-				} else {
-					common->Printf( "OpenAL: EFX extension not found\n" );
-					EAXAvailable = 0;
-					idSoundSystemLocal::s_useEAXReverb.SetBool( false );
-
-					alGenEffects = NULL;
-					alDeleteEffects = NULL;
-					alIsEffect = NULL;
-					alEffecti = NULL;
-					alEffectf = NULL;
-					alEffectfv = NULL;
-					alGenFilters = NULL;
-					alDeleteFilters = NULL;
-					alIsFilter = NULL;
-					alFilteri = NULL;
-					alFilterf = NULL;
-					alGenAuxiliaryEffectSlots = NULL;
-					alDeleteAuxiliaryEffectSlots = NULL;
-					alIsAuxiliaryEffectSlot = NULL;
-					alAuxiliaryEffectSloti = NULL;
-					alAuxiliaryEffectSlotf = NULL;
-				}
-			}
-			else
-			{
-				EAXAvailable = 0;
-			}
+#if ID_OPENAL_EAX
+	// try to obtain EAX extensions
+	if ( idSoundSystemLocal::s_useEAXReverb.GetBool() && alIsExtensionPresent( ID_ALCHAR "EAX4.0" ) ) {
+		alEAXSet = (EAXSet)alGetProcAddress( ID_ALCHAR "EAXSet" );
+		alEAXGet = (EAXGet)alGetProcAddress( ID_ALCHAR "EAXGet" );
+		common->Printf( "OpenAL: found EAX 4.0 extension\n" );
+		EAXAvailable = 1;
+	} else {
+		common->Printf( "OpenAL: EAX 4.0 extension not found\n" );
+		idSoundSystemLocal::s_useEAXReverb.SetBool( false );
+		alEAXSet = (EAXSet)NULL;
+		alEAXGet = (EAXGet)NULL;
+		EAXAvailable = 0;
+	}
 #else
-			// try to obtain EAX extensions
-			if (idSoundSystemLocal::s_useEAXReverb.GetBool() && alIsExtensionPresent(ID_ALCHAR "EAX4.0")) {
-				idSoundSystemLocal::s_useOpenAL.SetBool(true);	// EAX presence causes AL enable
-				alEAXSet = (EAXSet)alGetProcAddress(ID_ALCHAR "EAXSet");
-				alEAXGet = (EAXGet)alGetProcAddress(ID_ALCHAR "EAXGet");
-				common->Printf("OpenAL: found EAX 4.0 extension\n");
-			} else {
-				common->Printf("OpenAL: EAX 4.0 extension not found\n");
-				idSoundSystemLocal::s_useEAXReverb.SetBool(false);
-				alEAXSet = (EAXSet)NULL;
-				alEAXGet = (EAXGet)NULL;
-			}
+	common->Printf("OpenAL: EAX 4.0 not supported in this build\n");
+	idSoundSystemLocal::s_useEAXReverb.SetBool( false );
+	EAXAvailable = 0;
+#endif
 
-			// try to obtain EAX-RAM extension - not required for operation
-			if (alIsExtensionPresent(ID_ALCHAR "EAX-RAM") == AL_TRUE) {
-				alEAXSetBufferMode = (EAXSetBufferMode)alGetProcAddress(ID_ALCHAR "EAXSetBufferMode");
-				alEAXGetBufferMode = (EAXGetBufferMode)alGetProcAddress(ID_ALCHAR "EAXGetBufferMode");
-				common->Printf("OpenAL: found EAX-RAM extension, %dkB\\%dkB\n", alGetInteger(alGetEnumValue(ID_ALCHAR "AL_EAX_RAM_FREE")) / 1024, alGetInteger(alGetEnumValue(ID_ALCHAR "AL_EAX_RAM_SIZE")) / 1024);
-			} else {
-				alEAXSetBufferMode = (EAXSetBufferMode)NULL;
-				alEAXGetBufferMode = (EAXGetBufferMode)NULL;
-				common->Printf("OpenAL: no EAX-RAM extension\n");
-			}
+#if ID_OPENAL_EAX
+	// try to obtain EAX-RAM extension - not required for operation
+	if ( alIsExtensionPresent( ID_ALCHAR "EAX-RAM" ) == AL_TRUE ) {
+		alEAXSetBufferMode = (EAXSetBufferMode)alGetProcAddress( ID_ALCHAR "EAXSetBufferMode" );
+		alEAXGetBufferMode = (EAXGetBufferMode)alGetProcAddress( ID_ALCHAR "EAXGetBufferMode" );
+		common->Printf( "OpenAL: found EAX-RAM extension, %dkB\\%dkB\n", alGetInteger( alGetEnumValue( ID_ALCHAR "AL_EAX_RAM_FREE" ) ) / 1024, alGetInteger( alGetEnumValue( ID_ALCHAR "AL_EAX_RAM_SIZE" ) ) / 1024 );
+	} else {
+		alEAXSetBufferMode = (EAXSetBufferMode)NULL;
+		alEAXGetBufferMode = (EAXGetBufferMode)NULL;
+		common->Printf( "OpenAL: no EAX-RAM extension\n" );
+	}
 #endif
 
-			if (!idSoundSystemLocal::s_useOpenAL.GetBool()) {
-				common->Printf("OpenAL: disabling ( no EAX ). Using legacy mixer.\n");
+	ALuint handle;
+	openalSourceCount = 0;
 
-				alcMakeContextCurrent(NULL);
+	while ( openalSourceCount < 256 ) {
+		alGetError();
+		alGenSources( 1, &handle );
+		if ( alGetError() != AL_NO_ERROR ) {
+			break;
+		} else {
+			// store in source array
+			openalSources[openalSourceCount].handle = handle;
+			openalSources[openalSourceCount].startTime = 0;
+			openalSources[openalSourceCount].chan = NULL;
+			openalSources[openalSourceCount].inUse = false;
+			openalSources[openalSourceCount].looping = false;
 
-				alcDestroyContext(openalContext);
-				openalContext = NULL;
+			// initialise sources
+			alSourcef( handle, AL_ROLLOFF_FACTOR, 0.0f );
 
-				alcCloseDevice(openalDevice);
-				openalDevice = NULL;
-			} else {
-
-				ALuint handle;
-				openalSourceCount = 0;
-
-				while (openalSourceCount < 256) {
-					alGetError();
-					alGenSources(1, &handle);
-
-					if (alGetError() != AL_NO_ERROR) {
-						break;
-					} else {
-						// store in source array
-						openalSources[openalSourceCount].handle = handle;
-						openalSources[openalSourceCount].startTime = 0;
-						openalSources[openalSourceCount].chan = NULL;
-						openalSources[openalSourceCount].inUse = false;
-						openalSources[openalSourceCount].looping = false;
-
-						// initialise sources
-						alSourcef(handle, AL_ROLLOFF_FACTOR, 0.0f);
-
-						// found one source
-						openalSourceCount++;
-					}
-				}
-
-				common->Printf("OpenAL: found %s\n", alcGetString(openalDevice, ALC_DEVICE_SPECIFIER));
-				common->Printf("OpenAL: found %d hardware voices\n", openalSourceCount);
-
-				// adjust source count to allow for at least eight stereo sounds to play
-				openalSourceCount -= 8;
-
-#ifdef _OPENAL_SOFT
-				if(idSoundSystemLocal::s_useEAXReverb.GetBool())
-#endif
-				EAXAvailable = 1;
-			}
+			// found one source
+			openalSourceCount++;
 		}
 	}
 
-	useOpenAL = idSoundSystemLocal::s_useOpenAL.GetBool();
+	common->Printf( "OpenAL: found %s\n", alcGetString( openalDevice, ALC_DEVICE_SPECIFIER ) );
+	common->Printf( "OpenAL: found %d hardware voices\n", openalSourceCount );
+
+	// adjust source count to allow for at least eight stereo sounds to play
+	openalSourceCount -= 8;
+
 	useEAXReverb = idSoundSystemLocal::s_useEAXReverb.GetBool();
-#endif
 
-	cmdSystem->AddCommand("listSounds", ListSounds_f, CMD_FL_SOUND, "lists all sounds");
-	cmdSystem->AddCommand("listSoundDecoders", ListSoundDecoders_f, CMD_FL_SOUND, "list active sound decoders");
-	cmdSystem->AddCommand("reloadSounds", SoundReloadSounds_f, CMD_FL_SOUND|CMD_FL_CHEAT, "reloads all sounds");
-	cmdSystem->AddCommand("testSound", TestSound_f, CMD_FL_SOUND | CMD_FL_CHEAT, "tests a sound", idCmdSystem::ArgCompletion_SoundName);
-	cmdSystem->AddCommand("s_restart", SoundSystemRestart_f, CMD_FL_SOUND, "restarts the sound system");
+	cmdSystem->AddCommand( "listSounds", ListSounds_f, CMD_FL_SOUND, "lists all sounds" );
+	cmdSystem->AddCommand( "listSoundDecoders", ListSoundDecoders_f, CMD_FL_SOUND, "list active sound decoders" );
+	cmdSystem->AddCommand( "reloadSounds", SoundReloadSounds_f, CMD_FL_SOUND|CMD_FL_CHEAT, "reloads all sounds" );
+	cmdSystem->AddCommand( "testSound", TestSound_f, CMD_FL_SOUND | CMD_FL_CHEAT, "tests a sound", idCmdSystem::ArgCompletion_SoundName );
+	cmdSystem->AddCommand( "s_restart", SoundSystemRestart_f, CMD_FL_SOUND, "restarts the sound system" );
 
 #ifdef _HUMANHEAD
 	sb_subtitleQueue.Clear();
@@ -596,63 +471,46 @@ void idSoundSystemLocal::Init()
 idSoundSystemLocal::Shutdown
 ===============
 */
-void idSoundSystemLocal::Shutdown()
-{
+void idSoundSystemLocal::Shutdown() {
 	ShutdownHW();
 
-#ifdef _OPENAL
 	// EAX or not, the list needs to be cleared
 	EFXDatabase.Clear();
-#ifdef _RAVEN
-	reverb.Clear();
-#endif
 
-	// destroy openal sources
-	if (useOpenAL) {
+	efxloaded = false;
 
-		efxloaded = false;
+	// adjust source count back up to allow for freeing of all resources
+	openalSourceCount += 8;
 
-		// adjust source count back up to allow for freeing of all resources
-		openalSourceCount += 8;
+	for ( ALsizei i = 0; i < openalSourceCount; i++ ) {
+		// stop source
+		alSourceStop( openalSources[i].handle );
+		alSourcei( openalSources[i].handle, AL_BUFFER, 0 );
 
-		for (ALsizei i = 0; i < openalSourceCount; i++) {
-			// stop source
-			alSourceStop(openalSources[i].handle);
-			alSourcei(openalSources[i].handle, AL_BUFFER, 0);
+		// delete source
+		alDeleteSources( 1, &openalSources[i].handle );
 
-			// delete source
-			alDeleteSources(1, &openalSources[i].handle);
-
-			// clear entry in source array
-			openalSources[i].handle = 0;
-			openalSources[i].startTime = 0;
-			openalSources[i].chan = NULL;
-			openalSources[i].inUse = false;
-			openalSources[i].looping = false;
-
-		}
+		// clear entry in source array
+		openalSources[i].handle = 0;
+		openalSources[i].startTime = 0;
+		openalSources[i].chan = NULL;
+		openalSources[i].inUse = false;
+		openalSources[i].looping = false;
 	}
-#endif
 
 	// destroy all the sounds (hardware buffers as well)
 	delete soundCache;
 	soundCache = NULL;
 
-#ifdef _OPENAL
 	// destroy openal device and context
-	if (useOpenAL) {
-		alcMakeContextCurrent(NULL);
+	alcMakeContextCurrent( NULL );
 
-		alcDestroyContext(openalContext);
-		openalContext = NULL;
+	alcDestroyContext( openalContext );
+	openalContext = NULL;
 
-		alcCloseDevice(openalDevice);
-		openalDevice = NULL;
-	}
+	alcCloseDevice( openalDevice );
+	openalDevice = NULL;
 
-	Sys_FreeOpenAL();
-#endif
-
 	idSampleDecoder::Shutdown();
 }
 
@@ -661,35 +519,22 @@ void idSoundSystemLocal::Shutdown()
 idSoundSystemLocal::InitHW
 ===============
 */
-bool idSoundSystemLocal::InitHW()
-{
+bool idSoundSystemLocal::InitHW() {
+	int numSpeakers = s_numberOfSpeakers.GetInteger();
 
-	if (s_noSound.GetBool()) {
-		return false;
+	if (numSpeakers != 2 && numSpeakers != 6) {
+		common->Warning("invalid value for s_numberOfSpeakers. Use either 2 or 6");
+		numSpeakers = 2;
+		s_numberOfSpeakers.SetInteger(numSpeakers);
 	}
 
-	delete snd_audio_hw;
-	snd_audio_hw = idAudioHardware::Alloc();
-
-	if (snd_audio_hw == NULL) {
+	if ( s_noSound.GetBool() ) {
 		return false;
 	}
 
-	if (!useOpenAL) {
-		if (!snd_audio_hw->Initialize()) {
-			delete snd_audio_hw;
-			snd_audio_hw = NULL;
-			return false;
-		}
+	// put the real number in there
+	s_numberOfSpeakers.SetInteger(numSpeakers);
 
-		if (snd_audio_hw->GetNumberOfSpeakers() == 0) {
-			return false;
-		}
-
-		// put the real number in there
-		s_numberOfSpeakers.SetInteger(snd_audio_hw->GetNumberOfSpeakers());
-	}
-
 	isInitialized = true;
 	shutdown = false;
 
@@ -701,24 +546,20 @@ bool idSoundSystemLocal::InitHW()
 idSoundSystemLocal::ShutdownHW
 ===============
 */
-bool idSoundSystemLocal::ShutdownHW()
-{
-	if (!isInitialized) {
+bool idSoundSystemLocal::ShutdownHW() {
+	if ( !isInitialized ) {
 		return false;
 	}
 
 	shutdown = true;		// don't do anything at AsyncUpdate() time
-	Sys_Sleep(100);		// sleep long enough to make sure any async sound talking to hardware has returned
+	Sys_Sleep( 100 );		// sleep long enough to make sure any async sound talking to hardware has returned
 
-	common->Printf("Shutting down sound hardware\n");
+	common->Printf( "Shutting down sound hardware\n" );
 
-	delete snd_audio_hw;
-	snd_audio_hw = NULL;
-
 	isInitialized = false;
 
-	if (graph) {
-		Mem_Free(graph);
+	if ( graph ) {
+		Mem_Free( graph );
 		graph = NULL;
 	}
 
@@ -730,67 +571,35 @@ bool idSoundSystemLocal::ShutdownHW()
 idSoundSystemLocal::GetCurrent44kHzTime
 ===============
 */
-int idSoundSystemLocal::GetCurrent44kHzTime(void) const
-{
-	if (snd_audio_hw
-/*#ifdef _OPENAL
-        || useOpenAL
-#endif*/
-	) {
+int idSoundSystemLocal::GetCurrent44kHzTime( void ) const {
+	if ( isInitialized ) {
 		return CurrentSoundTime;
 	} else {
-		// NOTE: this would overflow 31bits within about 1h20 ( not that important since we get a snd_audio_hw right away pbly )
+		// NOTE: this would overflow 31bits within about 1h20
 		//return ( ( Sys_Milliseconds()*441 ) / 10 ) * 4;
-		return idMath::FtoiFast((float)Sys_Milliseconds() * 176.4f);
+		return idMath::FtoiFast( (float)Sys_Milliseconds() * 176.4f );
 	}
 }
 
 /*
 ===================
-idSoundSystemLocal::ClearBuffer
-===================
-*/
-void idSoundSystemLocal::ClearBuffer(void)
-{
-
-	// check to make sure hardware actually exists
-	if (!snd_audio_hw) {
-		return;
-	}
-
-	short *fBlock;
-	ulong fBlockLen;
-
-	if (!snd_audio_hw->Lock((void **)&fBlock, &fBlockLen)) {
-		return;
-	}
-
-	if (fBlock) {
-		SIMDProcessor->Memset(fBlock, 0, fBlockLen);
-		snd_audio_hw->Unlock(fBlock, fBlockLen);
-	}
-}
-
-/*
-===================
 idSoundSystemLocal::AsyncMix
 Mac OSX version. The system uses it's own thread and an IOProc callback
 ===================
 */
-int idSoundSystemLocal::AsyncMix(int soundTime, float *mixBuffer)
-{
+int idSoundSystemLocal::AsyncMix( int soundTime, float *mixBuffer ) {
 	int	inTime, numSpeakers;
 
-	if (!isInitialized || shutdown || !snd_audio_hw) {
+	if ( !isInitialized || shutdown ) {
 		return 0;
 	}
 
 	inTime = Sys_Milliseconds();
-	numSpeakers = snd_audio_hw->GetNumberOfSpeakers();
+	numSpeakers = s_numberOfSpeakers.GetInteger();
 
 	// let the active sound world mix all the channels in unless muted or avi demo recording
-	if (!muted && currentSoundWorld && !currentSoundWorld->fpa[0]) {
-		currentSoundWorld->MixLoop(soundTime, numSpeakers, mixBuffer);
+	if ( !muted && currentSoundWorld && !currentSoundWorld->fpa[0] ) {
+		currentSoundWorld->MixLoop( soundTime, numSpeakers, mixBuffer );
 	}
 
 	CurrentSoundTime = soundTime;
@@ -804,9 +613,9 @@ idSoundSystemLocal::AsyncUpdate
 called from async sound thread when com_asyncSound == 1 ( Windows )
 ===================
 */
-int idSoundSystemLocal::AsyncUpdate(int inTime)
-{
-	if (!isInitialized || shutdown || !snd_audio_hw) {
+int idSoundSystemLocal::AsyncUpdate( int inTime ) {
+
+	if ( !isInitialized || shutdown ) {
 		return 0;
 	}
 #ifdef _HUMANHEAD
@@ -815,57 +624,30 @@ int idSoundSystemLocal::AsyncUpdate(int inTime)
 
 	ulong dwCurrentWritePos;
 	dword dwCurrentBlock;
-#ifdef _OPENAL
-	// If not using openal, get actual playback position from sound hardware
-	if (useOpenAL) {
-		// here we do it in samples ( overflows in 27 hours or so )
-		dwCurrentWritePos = idMath::Ftol((float)Sys_Milliseconds() * 44.1f) % (MIXBUFFER_SAMPLES * ROOM_SLICES_IN_BUFFER);
-		dwCurrentBlock = dwCurrentWritePos / MIXBUFFER_SAMPLES;
-	} else 
-#endif
-	{
-		// and here in bytes
-		// get the current byte position in the buffer where the sound hardware is currently reading
-		if (!snd_audio_hw->GetCurrentPosition(&dwCurrentWritePos)) {
-			return 0;
-		}
 
-		// mixBufferSize is in bytes
-		dwCurrentBlock = dwCurrentWritePos / snd_audio_hw->GetMixBufferSize();
-	}
+	// here we do it in samples ( overflows in 27 hours or so )
+	dwCurrentWritePos = idMath::Ftol( (float)Sys_Milliseconds() * 44.1f ) % ( MIXBUFFER_SAMPLES * ROOM_SLICES_IN_BUFFER );
+	dwCurrentBlock = dwCurrentWritePos / MIXBUFFER_SAMPLES;
 
-	if (nextWriteBlock == 0xffffffff) {
+	if ( nextWriteBlock == 0xffffffff ) {
 		nextWriteBlock = dwCurrentBlock;
 	}
 
-	if (dwCurrentBlock != nextWriteBlock) {
+	if ( dwCurrentBlock != nextWriteBlock ) {
 		return 0;
 	}
 
-	// lock the buffer so we can actually write to it
-	short *fBlock = NULL;
-	ulong fBlockLen = 0;
-
-	if (!useOpenAL) {
-		snd_audio_hw->Lock((void **)&fBlock, &fBlockLen);
-
-		if (!fBlock) {
-			return 0;
-		}
-	}
-
-	int j;
 	soundStats.runs++;
 	soundStats.activeSounds = 0;
 
-	int	numSpeakers = snd_audio_hw->GetNumberOfSpeakers();
+	int	numSpeakers = s_numberOfSpeakers.GetInteger();
 
 	nextWriteBlock++;
 	nextWriteBlock %= ROOM_SLICES_IN_BUFFER;
 
 	int newPosition = nextWriteBlock * MIXBUFFER_SAMPLES;
 
-	if (newPosition < olddwCurrentWritePos) {
+	if ( newPosition < olddwCurrentWritePos ) {
 		buffers++;					// buffer wrapped
 	}
 
@@ -875,56 +657,29 @@ int idSoundSystemLocal::AsyncUpdate(int inTime)
 	olddwCurrentWritePos = newPosition;
 
 	// newSoundTime is in multi-channel samples since the sound system was started
-	int newSoundTime = (buffers * MIXBUFFER_SAMPLES * ROOM_SLICES_IN_BUFFER) + nextWriteSamples;
+	int newSoundTime = ( buffers * MIXBUFFER_SAMPLES * ROOM_SLICES_IN_BUFFER ) + nextWriteSamples;
 
 	// check for impending overflow
 	// FIXME: we don't handle sound wrap-around correctly yet
-	if (newSoundTime > 0x6fffffff) {
+	if ( newSoundTime > 0x6fffffff ) {
 		buffers = 0;
 	}
 
-	if ((newSoundTime - CurrentSoundTime) > (int)MIXBUFFER_SAMPLES) {
+	if ( (newSoundTime - CurrentSoundTime) > (int)MIXBUFFER_SAMPLES ) {
 		soundStats.missedWindow++;
 	}
-#ifdef _OPENAL
-	if (useOpenAL) {
-		// enable audio hardware caching
-		alcSuspendContext(openalContext);
-	} else 
-#endif
-	{
-		// clear the buffer for all the mixing output
-		SIMDProcessor->Memset(finalMixBuffer, 0, MIXBUFFER_SAMPLES * sizeof(float) * numSpeakers);
-	}
 
+	// enable audio hardware caching
+	alcSuspendContext( openalContext );
+
 	// let the active sound world mix all the channels in unless muted or avi demo recording
-	if (!muted && currentSoundWorld && !currentSoundWorld->fpa[0]) {
-		currentSoundWorld->MixLoop(newSoundTime, numSpeakers, finalMixBuffer);
+	if ( !muted && currentSoundWorld && !currentSoundWorld->fpa[0] ) {
+		currentSoundWorld->MixLoop( newSoundTime, numSpeakers, finalMixBuffer );
 	}
-#ifdef _OPENAL
-	if (useOpenAL) {
-		// disable audio hardware caching (this updates ALL settings since last alcSuspendContext)
-		alcProcessContext(openalContext);
-	} 
-	else
-#endif
-	{
-		short *dest = fBlock + nextWriteSamples * numSpeakers;
 
-		SIMDProcessor->MixedSoundToSamples(dest, finalMixBuffer, MIXBUFFER_SAMPLES * numSpeakers);
+	// disable audio hardware caching (this updates ALL settings since last alcSuspendContext)
+	alcProcessContext( openalContext );
 
-		// allow swapping the left / right speaker channels for people with miswired systems
-		if (numSpeakers == 2 && s_reverse.GetBool()) {
-			for (j = 0; j < MIXBUFFER_SAMPLES; j++) {
-				short temp = dest[j*2];
-				dest[j*2] = dest[j*2+1];
-				dest[j*2+1] = temp;
-			}
-		}
-
-		snd_audio_hw->Unlock(fBlock, fBlockLen);
-	}
-
 	CurrentSoundTime = newSoundTime;
 
 	soundStats.timeinprocess = Sys_Milliseconds() - inTime;
@@ -943,76 +698,47 @@ we mix MIXBUFFER_SAMPLES at a time, but we feed the au
 called by the sound thread when com_asyncSound is 3 ( Linux )
 ===================
 */
-int idSoundSystemLocal::AsyncUpdateWrite(int inTime)
-{
-	if (!isInitialized || shutdown || !snd_audio_hw) {
+int idSoundSystemLocal::AsyncUpdateWrite( int inTime ) {
+
+	if ( !isInitialized || shutdown ) {
 		return 0;
 	}
 #ifdef _HUMANHEAD
 	SB_HideSubtitle();
 #endif
 
-	if (!useOpenAL) {
-		snd_audio_hw->Flush();
-	}
+	//if (!useOpenAL) {
+	//	snd_audio_hw->Flush();
+	//}
 
-	unsigned int dwCurrentBlock = (unsigned int)(inTime * 44.1f / MIXBUFFER_SAMPLES);
+	unsigned int dwCurrentBlock = (unsigned int)( inTime * 44.1f / MIXBUFFER_SAMPLES );
 
-	if (nextWriteBlock == 0xffffffff) {
+	if ( nextWriteBlock == 0xffffffff ) {
 		nextWriteBlock = dwCurrentBlock;
 	}
 
-	if (dwCurrentBlock < nextWriteBlock) {
+	if ( dwCurrentBlock < nextWriteBlock ) {
 		return 0;
 	}
 
-	if (nextWriteBlock != dwCurrentBlock) {
-		Sys_Printf("missed %d sound updates\n", dwCurrentBlock - nextWriteBlock);
+	if ( nextWriteBlock != dwCurrentBlock ) {
+		Sys_Printf( "missed %d sound updates\n", dwCurrentBlock - nextWriteBlock );
 	}
 
 	int sampleTime = dwCurrentBlock * MIXBUFFER_SAMPLES;
-	int numSpeakers = snd_audio_hw->GetNumberOfSpeakers();
-#ifdef _OPENAL
-	if (useOpenAL) {
-		// enable audio hardware caching
-		alcSuspendContext(openalContext);
-	} else
-#endif
-	{
-		// clear the buffer for all the mixing output
-		SIMDProcessor->Memset(finalMixBuffer, 0, MIXBUFFER_SAMPLES * sizeof(float) * numSpeakers);
-	}
+	int numSpeakers = s_numberOfSpeakers.GetInteger();
 
+	// enable audio hardware caching
+	alcSuspendContext( openalContext );
+
 	// let the active sound world mix all the channels in unless muted or avi demo recording
-	if (!muted && currentSoundWorld && !currentSoundWorld->fpa[0]) {
-		currentSoundWorld->MixLoop(sampleTime, numSpeakers, finalMixBuffer);
+	if ( !muted && currentSoundWorld && !currentSoundWorld->fpa[0] ) {
+		currentSoundWorld->MixLoop( sampleTime, numSpeakers, finalMixBuffer );
 	}
-#ifdef _OPENAL
-	if (useOpenAL) {
-		// disable audio hardware caching (this updates ALL settings since last alcSuspendContext)
-		alcProcessContext(openalContext);
-	} 
-	else
-#endif
-	{
-		short *dest = snd_audio_hw->GetMixBuffer();
 
-		SIMDProcessor->MixedSoundToSamples(dest, finalMixBuffer, MIXBUFFER_SAMPLES * numSpeakers);
+	// disable audio hardware caching (this updates ALL settings since last alcSuspendContext)
+	alcProcessContext( openalContext );
 
-		// allow swapping the left / right speaker channels for people with miswired systems
-		if (numSpeakers == 2 && s_reverse.GetBool()) {
-			int j;
-
-			for (j = 0; j < MIXBUFFER_SAMPLES; j++) {
-				short temp = dest[j*2];
-				dest[j*2] = dest[j*2+1];
-				dest[j*2+1] = temp;
-			}
-		}
-
-		snd_audio_hw->Write(false);
-	}
-
 	// only move to the next block if the write was successful
 	nextWriteBlock = dwCurrentBlock + 1;
 	CurrentSoundTime = sampleTime;
@@ -1028,17 +754,15 @@ int idSoundSystemLocal::AsyncUpdateWrite(int inTime)
 idSoundSystemLocal::dB2Scale
 ===================
 */
-float idSoundSystemLocal::dB2Scale(const float val) const
-{
-	if (val == 0.0f) {
+float idSoundSystemLocal::dB2Scale( const float val ) const {
+	if ( val == 0.0f ) {
 		return 1.0f;				// most common
-	} else if (val <= -60.0f) {
+	} else if ( val <= -60.0f ) {
 		return 0.0f;
-	} else if (val >= 60.0f) {
-		return powf(2.0f, val * (1.0f / 6.0f));
+	} else if ( val >= 60.0f ) {
+		return powf( 2.0f, val * ( 1.0f / 6.0f ) );
 	}
-
-	int ival = (int)((val + 60.0f) * 10.0f);
+	int ival = (int)( ( val + 60.0f ) * 10.0f );
 	return volumesDB[ival];
 }
 
@@ -1047,119 +771,101 @@ float idSoundSystemLocal::dB2Scale(const float val) co
 idSoundSystemLocal::ImageForTime
 ===================
 */
-cinData_t idSoundSystemLocal::ImageForTime(const int milliseconds, const bool waveform)
-{
+cinData_t idSoundSystemLocal::ImageForTime( const int milliseconds, const bool waveform ) {
 	cinData_t ret;
 	int i, j;
 
-	if (!isInitialized || !snd_audio_hw) {
-		memset(&ret, 0, sizeof(ret));
+	if ( !isInitialized ) {
+		memset( &ret, 0, sizeof( ret ) );
 		return ret;
 	}
 
 	Sys_EnterCriticalSection();
 
-	if (!graph) {
-		graph = (dword *)Mem_Alloc(256*128 * 4);
+	if ( !graph ) {
+		graph = (dword *)Mem_Alloc( 256*128 * 4);
 	}
-
-	memset(graph, 0, 256*128 * 4);
+	memset( graph, 0, 256*128 * 4 );
 	float *accum = finalMixBuffer;	// unfortunately, these are already clamped
 	int time = Sys_Milliseconds();
 
-	int numSpeakers = snd_audio_hw->GetNumberOfSpeakers();
+	int numSpeakers = s_numberOfSpeakers.GetInteger();
 
-	if (!waveform) {
-		for (j = 0; j < numSpeakers; j++) {
+	if ( !waveform ) {
+		for( j = 0; j < numSpeakers; j++ ) {
 			int meter = 0;
-
-			for (i = 0; i < MIXBUFFER_SAMPLES; i++) {
+			for( i = 0; i < MIXBUFFER_SAMPLES; i++ ) {
 				float result = idMath::Fabs(accum[i*numSpeakers+j]);
-
-				if (result > meter) {
+				if ( result > meter ) {
 					meter = result;
 				}
 			}
 
 			meter /= 256;		// 32768 becomes 128
-
-			if (meter > 128) {
+			if ( meter > 128 ) {
 				meter = 128;
 			}
-
 			int offset;
 			int xsize;
-
-			if (numSpeakers == 6) {
+			if ( numSpeakers == 6 ) {
 				offset = j * 40;
 				xsize = 20;
 			} else {
 				offset = j * 128;
 				xsize = 63;
 			}
-
 			int x,y;
 			dword color = 0xff00ff00;
-
-			for (y = 0; y < 128; y++) {
-				for (x = 0; x < xsize; x++) {
+			for ( y = 0; y < 128; y++ ) {
+				for ( x = 0; x < xsize; x++ ) {
 					graph[(127-y)*256 + offset + x ] = color;
 				}
-
 #if 0
-
-				if (y == 80) {
+				if ( y == 80 ) {
 					color = 0xff00ffff;
-				} else if (y == 112) {
+				} else if ( y == 112 ) {
 					color = 0xff0000ff;
 				}
-
 #endif
-
-				if (y > meter) {
+				if ( y > meter ) {
 					break;
 				}
 			}
 
-			if (meter > meterTops[j]) {
+			if ( meter > meterTops[j] ) {
 				meterTops[j] = meter;
 				meterTopsTime[j] = time + s_meterTopTime.GetInteger();
-			} else if (time > meterTopsTime[j] && meterTops[j] > 0) {
+			} else if ( time > meterTopsTime[j] && meterTops[j] > 0 ) {
 				meterTops[j]--;
-
 				if (meterTops[j]) {
 					meterTops[j]--;
 				}
 			}
 		}
 
-		for (j = 0; j < numSpeakers; j++) {
+		for( j = 0; j < numSpeakers; j++ ) {
 			int meter = meterTops[j];
 
 			int offset;
 			int xsize;
-
-			if (numSpeakers == 6) {
+			if ( numSpeakers == 6 ) {
 				offset = j*40;
 				xsize = 20;
 			} else {
 				offset = j*128;
 				xsize = 63;
 			}
-
 			int x,y;
 			dword color;
-
-			if (meter <= 80) {
+			if ( meter <= 80 ) {
 				color = 0xff007f00;
-			} else if (meter <= 112) {
+			} else if ( meter <= 112 ) {
 				color = 0xff007f7f;
 			} else {
 				color = 0xff00007f;
 			}
-
-			for (y = meter; y < 128 && y < meter + 4; y++) {
-				for (x = 0; x < xsize; x++) {
+			for ( y = meter; y < 128 && y < meter + 4; y++ ) {
+				for ( x = 0; x < xsize; x++ ) {
 					graph[(127-y)*256 + offset + x ] = color;
 				}
 			}
@@ -1167,59 +873,48 @@ cinData_t idSoundSystemLocal::ImageForTime(const int m
 	} else {
 		dword colors[] = { 0xff007f00, 0xff007f7f, 0xff00007f, 0xff00ff00, 0xff00ffff, 0xff0000ff };
 
-		for (j = 0; j < numSpeakers; j++) {
+		for( j = 0; j < numSpeakers; j++ ) {
 			int xx = 0;
 			float fmeter;
 			int step = MIXBUFFER_SAMPLES / 256;
-
-			for (i = 0; i < MIXBUFFER_SAMPLES; i += step) {
+			for( i = 0; i < MIXBUFFER_SAMPLES; i += step ) {
 				fmeter = 0.0f;
-
-				for (int x = 0; x < step; x++) {
+				for( int x = 0; x < step; x++ ) {
 					float result = accum[(i+x)*numSpeakers+j];
 					result = result / 32768.0f;
 					fmeter += result;
 				}
-
 				fmeter /= 4.0f;
-
-				if (fmeter < -1.0f) {
+				if ( fmeter < -1.0f ) {
 					fmeter = -1.0f;
-				} else if (fmeter > 1.0f) {
+				} else if ( fmeter > 1.0f ) {
 					fmeter = 1.0f;
 				}
-
 				int meter = (fmeter * 63.0f);
-				graph[(meter + 64) * 256 + xx ] = colors[j];
+				graph[ (meter + 64) * 256 + xx ] = colors[j];
 
-				if (meter < 0) {
+				if ( meter < 0 ) {
 					meter = -meter;
 				}
-
-				if (meter > meterTops[xx]) {
+				if ( meter > meterTops[xx] ) {
 					meterTops[xx] = meter;
 					meterTopsTime[xx] = time + 100;
-				} else if (time>meterTopsTime[xx] && meterTops[xx] > 0) {
+				} else if ( time>meterTopsTime[xx] && meterTops[xx] > 0 ) {
 					meterTops[xx]--;
-
-					if (meterTops[xx]) {
+					if ( meterTops[xx] ) {
 						meterTops[xx]--;
 					}
 				}
-
 				xx++;
 			}
 		}
-
-		for (i = 0; i < 256; i++) {
+		for( i = 0; i < 256; i++ ) {
 			int meter = meterTops[i];
-
-			for (int y = -meter; y < meter; y++) {
-				graph[(y+64)*256 + i ] = colors[j];
+			for ( int y = -meter; y < meter; y++ ) {
+				graph[ (y+64)*256 + i ] = colors[j];
 			}
 		}
 	}
-
 	ret.imageHeight = 128;
 	ret.imageWidth = 256;
 	ret.image = (unsigned char *)graph;
@@ -1234,12 +929,11 @@ cinData_t idSoundSystemLocal::ImageForTime(const int m
 idSoundSystemLocal::GetSoundDecoderInfo
 ===================
 */
-int idSoundSystemLocal::GetSoundDecoderInfo(int index, soundDecoderInfo_t &decoderInfo)
-{
+int idSoundSystemLocal::GetSoundDecoderInfo( int index, soundDecoderInfo_t &decoderInfo ) {
 	int i, j, firstEmitter, firstChannel;
 	idSoundWorldLocal *sw = soundSystemLocal.currentSoundWorld;
 
-	if (index < 0) {
+	if ( index < 0 ) {
 		firstEmitter = 0;
 		firstChannel = 0;
 	} else {
@@ -1247,44 +941,43 @@ int idSoundSystemLocal::GetSoundDecoderInfo(int index,
 		firstChannel = index - firstEmitter * SOUND_MAX_CHANNELS + 1;
 	}
 
-	for (i = firstEmitter; i < sw->emitters.Num(); i++) {
+	for ( i = firstEmitter; i < sw->emitters.Num(); i++ ) {
 		idSoundEmitterLocal *sound = sw->emitters[i];
 
-		if (!sound) {
+		if ( !sound ) {
 			continue;
 		}
 
 		// run through all the channels
-		for (j = firstChannel; j < SOUND_MAX_CHANNELS; j++) {
+		for ( j = firstChannel; j < SOUND_MAX_CHANNELS; j++ ) {
 			idSoundChannel	*chan = &sound->channels[j];
 
-			if (chan->decoder == NULL) {
+			if ( chan->decoder == NULL ) {
 				continue;
 			}
 
 			idSoundSample *sample = chan->decoder->GetSample();
 
-			if (sample == NULL) {
+			if ( sample == NULL ) {
 				continue;
 			}
 
 			decoderInfo.name = sample->name;
-			decoderInfo.format = (sample->objectInfo.wFormatTag == WAVE_FORMAT_TAG_OGG) ? "OGG" : "WAV";
+			decoderInfo.format = ( sample->objectInfo.wFormatTag == WAVE_FORMAT_TAG_OGG ) ? "OGG" : "WAV";
 			decoderInfo.numChannels = sample->objectInfo.nChannels;
 			decoderInfo.numSamplesPerSecond = sample->objectInfo.nSamplesPerSec;
 			decoderInfo.num44kHzSamples = sample->LengthIn44kHzSamples();
 			decoderInfo.numBytes = sample->objectMemSize;
-			decoderInfo.looping = (chan->parms.soundShaderFlags & SSF_LOOPING) != 0;
+			decoderInfo.looping = ( chan->parms.soundShaderFlags & SSF_LOOPING ) != 0;
 			decoderInfo.lastVolume = chan->lastVolume;
 			decoderInfo.start44kHzTime = chan->trigger44kHzTime;
 			decoderInfo.current44kHzTime = soundSystemLocal.GetCurrent44kHzTime();
 
-			return (i * SOUND_MAX_CHANNELS + j);
+			return ( i * SOUND_MAX_CHANNELS + j );
 		}
 
 		firstChannel = 0;
 	}
-
 	return -1;
 }
 
@@ -1293,11 +986,10 @@ int idSoundSystemLocal::GetSoundDecoderInfo(int index,
 idSoundSystemLocal::AllocSoundWorld
 ===================
 */
-idSoundWorld *idSoundSystemLocal::AllocSoundWorld(idRenderWorld *rw)
-{
+idSoundWorld *idSoundSystemLocal::AllocSoundWorld( idRenderWorld *rw ) {
 	idSoundWorldLocal	*local = new idSoundWorldLocal;
 
-	local->Init(rw);
+	local->Init( rw );
 
 	return local;
 }
@@ -1307,8 +999,7 @@ idSoundWorld *idSoundSystemLocal::AllocSoundWorld(idRe
 idSoundSystemLocal::SetMute
 ===================
 */
-void idSoundSystemLocal::SetMute(bool muteOn)
-{
+void idSoundSystemLocal::SetMute( bool muteOn ) {
 	muted = muteOn;
 }
 
@@ -1317,9 +1008,8 @@ void idSoundSystemLocal::SetMute(bool muteOn)
 idSoundSystemLocal::SamplesToMilliseconds
 ===================
 */
-int idSoundSystemLocal::SamplesToMilliseconds(int samples) const
-{
-	return (samples / (PRIMARYFREQ/1000));
+int idSoundSystemLocal::SamplesToMilliseconds( int samples ) const {
+	return ( samples / (PRIMARYFREQ/1000) );
 }
 
 /*
@@ -1327,9 +1017,8 @@ int idSoundSystemLocal::SamplesToMilliseconds(int samp
 idSoundSystemLocal::SamplesToMilliseconds
 ===================
 */
-int idSoundSystemLocal::MillisecondsToSamples(int ms) const
-{
-	return (ms * (PRIMARYFREQ/1000));
+int idSoundSystemLocal::MillisecondsToSamples( int ms ) const {
+	return ( ms * (PRIMARYFREQ/1000) );
 }
 
 /*
@@ -1339,8 +1028,7 @@ idSoundSystemLocal::SetPlayingSoundWorld
 specifying NULL will cause silence to be played
 ===================
 */
-void idSoundSystemLocal::SetPlayingSoundWorld(idSoundWorld *soundWorld)
-{
+void idSoundSystemLocal::SetPlayingSoundWorld( idSoundWorld *soundWorld ) {
 	currentSoundWorld = static_cast<idSoundWorldLocal *>(soundWorld);
 }
 
@@ -1349,8 +1037,7 @@ void idSoundSystemLocal::SetPlayingSoundWorld(idSoundW
 idSoundSystemLocal::GetPlayingSoundWorld
 ===================
 */
-idSoundWorld *idSoundSystemLocal::GetPlayingSoundWorld(void)
-{
+idSoundWorld *idSoundSystemLocal::GetPlayingSoundWorld( void ) {
 	return currentSoundWorld;
 }
 
@@ -1360,20 +1047,17 @@ idSoundSystemLocal::BeginLevelLoad
 ===================
 */
 
-void idSoundSystemLocal::BeginLevelLoad()
-{
-	if (!isInitialized) {
+void idSoundSystemLocal::BeginLevelLoad() {
+	if ( !isInitialized ) {
 		return;
 	}
-
 	soundCache->BeginLevelLoad();
 
-#ifdef _OPENAL
-	if (efxloaded) {
+	if ( efxloaded ) {
 		EFXDatabase.UnloadFile();
 		efxloaded = false;
 	}
-#endif
+
 #ifdef _RAVEN
 	reverb.UnloadFile();
 #endif
@@ -1384,31 +1068,24 @@ void idSoundSystemLocal::BeginLevelLoad()
 idSoundSystemLocal::EndLevelLoad
 ===================
 */
-void idSoundSystemLocal::EndLevelLoad(const char *mapstring)
-{
-	if (!isInitialized) {
+void idSoundSystemLocal::EndLevelLoad( const char *mapstring ) {
+	if ( !isInitialized ) {
 		return;
 	}
-
 	soundCache->EndLevelLoad();
 
-#ifdef _OPENAL
-#ifdef _OPENAL_EFX
-	if (!useEAXReverb)
-		return;
-#endif
+#if ID_OPENAL_EAX
+	idStr efxname( "efxs/" );
+	idStr mapname( mapstring );
 
-	idStr efxname("efxs/");
-	idStr mapname(mapstring);
-
-	mapname.SetFileExtension(".efx");
+	mapname.SetFileExtension( ".efx" );
 	mapname.StripPath();
 	efxname += mapname;
 
-	efxloaded = EFXDatabase.LoadFile(efxname);
+	efxloaded = EFXDatabase.LoadFile( efxname );
 
-	if (efxloaded) {
-		common->Printf("sound: found %s\n", efxname.c_str());
+	if ( efxloaded ) {
+		common->Printf("sound: found %s\n", efxname.c_str() );
 	} else {
 #ifdef _RAVEN //karin: Quake4 has efxs/default.efx
 		efxloaded = EFXDatabase.LoadFile("efxs/default.efx");
@@ -1439,9 +1116,7 @@ void idSoundSystemLocal::EndLevelLoad(const char *maps
 idSoundSystemLocal::AllocOpenALSource
 ===================
 */
-ALuint idSoundSystemLocal::AllocOpenALSource(idSoundChannel *chan, bool looping, bool stereo)
-{
-#ifdef _OPENAL
+ALuint idSoundSystemLocal::AllocOpenALSource( idSoundChannel *chan, bool looping, bool stereo ) {
 	int timeOldestZeroVolSingleShot = Sys_Milliseconds();
 	int timeOldestZeroVolLooping = Sys_Milliseconds();
 	int timeOldestSingle = Sys_Milliseconds();
@@ -1456,47 +1131,47 @@ ALuint idSoundSystemLocal::AllocOpenALSource(idSoundCh
 	int time = Sys_Milliseconds();
 
 	// Cycle through all sources
-	for (i = 0; i < openalSourceCount; i++) {
+	for ( i = 0; i < openalSourceCount; i++ ) {
 		// Use any unused source first,
 		// Then find oldest single shot quiet source,
 		// Then find oldest looping quiet source and
 		// Lastly find oldest single shot non quiet source..
-		if (!openalSources[i].inUse) {
+		if ( !openalSources[i].inUse ) {
 			iUnused = i;
 			break;
-		}  else if (!openalSources[i].looping && openalSources[i].chan->lastVolume < SND_EPSILON) {
-			if (openalSources[i].startTime < timeOldestZeroVolSingleShot) {
+		}  else if ( !openalSources[i].looping && openalSources[i].chan->lastVolume < SND_EPSILON ) {
+			if ( openalSources[i].startTime < timeOldestZeroVolSingleShot ) {
 				timeOldestZeroVolSingleShot = openalSources[i].startTime;
 				iOldestZeroVolSingleShot = i;
 			}
-		} else if (openalSources[i].looping && openalSources[i].chan->lastVolume < SND_EPSILON) {
-			if (openalSources[i].startTime < timeOldestZeroVolLooping) {
+		} else if ( openalSources[i].looping && openalSources[i].chan->lastVolume < SND_EPSILON ) {
+			if ( openalSources[i].startTime < timeOldestZeroVolLooping ) {
 				timeOldestZeroVolLooping = openalSources[i].startTime;
 				iOldestZeroVolLooping = i;
 			}
-		} else if (!openalSources[i].looping) {
-			if (openalSources[i].startTime < timeOldestSingle) {
+		} else if ( !openalSources[i].looping ) {
+			if ( openalSources[i].startTime < timeOldestSingle ) {
 				timeOldestSingle = openalSources[i].startTime;
 				iOldestSingle = i;
 			}
 		}
 	}
 
-	if (iUnused != -1) {
+	if ( iUnused != -1 ) {
 		index = iUnused;
-	} else if (iOldestZeroVolSingleShot != - 1) {
+	} else if ( iOldestZeroVolSingleShot != - 1 ) {
 		index = iOldestZeroVolSingleShot;
-	} else if (iOldestZeroVolLooping != -1) {
+	} else if ( iOldestZeroVolLooping != -1 ) {
 		index = iOldestZeroVolLooping;
-	} else if (iOldestSingle != -1) {
+	} else if ( iOldestSingle != -1 ) {
 		index = iOldestSingle;
 	}
 
-	if (index != -1) {
+	if ( index != -1 ) {
 		// stop the channel that is being ripped off
-		if (openalSources[index].chan) {
+		if ( openalSources[index].chan ) {
 			// stop the channel only when not looping
-			if (!openalSources[index].looping) {
+			if ( !openalSources[index].looping ) {
 				openalSources[index].chan->Stop();
 			} else {
 				openalSources[index].chan->triggered = true;
@@ -1517,9 +1192,6 @@ ALuint idSoundSystemLocal::AllocOpenALSource(idSoundCh
 	} else {
 		return 0;
 	}
-#else
-	return 0;
-#endif
 }
 
 /*
@@ -1527,26 +1199,20 @@ ALuint idSoundSystemLocal::AllocOpenALSource(idSoundCh
 idSoundSystemLocal::FreeOpenALSource
 ===================
 */
-void idSoundSystemLocal::FreeOpenALSource(ALuint handle)
-{
-#ifdef _OPENAL
+void idSoundSystemLocal::FreeOpenALSource( ALuint handle ) {
 	ALsizei i;
-
-	for (i = 0; i < openalSourceCount; i++) {
-		if (openalSources[i].handle == handle) {
-			if (openalSources[i].chan) {
+	for ( i = 0; i < openalSourceCount; i++ ) {
+		if ( openalSources[i].handle == handle ) {
+			if ( openalSources[i].chan ) {
 				openalSources[i].chan->openalSource = 0;
 			}
-
-#if ID_OPENAL
-#if !defined(_OPENAL_EFX)
+#if ID_OPENAL_EAX
 			// Reset source EAX ROOM level when freeing stereo source
-			if (openalSources[i].stereo && alEAXSet) {
+			if ( openalSources[i].stereo && alEAXSet ) {
 				long Room = EAXSOURCE_DEFAULTROOM;
-				alEAXSet(&EAXPROPERTYID_EAX_Source, EAXSOURCE_ROOM, openalSources[i].handle, &Room, sizeof(Room));
+				alEAXSet( &EAXPROPERTYID_EAX_Source, EAXSOURCE_ROOM, openalSources[i].handle, &Room, sizeof(Room));
 			}
 #endif
-#endif
 			// Initialize structure
 			openalSources[i].startTime = 0;
 			openalSources[i].chan = NULL;
@@ -1555,7 +1221,6 @@ void idSoundSystemLocal::FreeOpenALSource(ALuint handl
 			openalSources[i].stereo = false;
 		}
 	}
-#endif
 }
 
 /*
@@ -1569,35 +1234,32 @@ SoundFX and misc effects
 idSoundSystemLocal::ProcessSample
 ===================
 */
-void SoundFX_Lowpass::ProcessSample(float *in, float *out)
-{
+void SoundFX_Lowpass::ProcessSample( float* in, float* out ) {
 	float c, a1, a2, a3, b1, b2;
 	float resonance = idSoundSystemLocal::s_enviroSuitCutoffQ.GetFloat();
 	float cutoffFrequency = idSoundSystemLocal::s_enviroSuitCutoffFreq.GetFloat();
 
 	Initialize();
 
-	c = 1.0 / idMath::Tan16(idMath::PI * cutoffFrequency / 44100);
+	c = 1.0 / idMath::Tan16( idMath::PI * cutoffFrequency / 44100 );
 
 	// compute coefs
-	a1 = 1.0 / (1.0 + resonance * c + c * c);
+	a1 = 1.0 / ( 1.0 + resonance * c + c * c );
 	a2 = 2* a1;
 	a3 = a1;
-	b1 = 2.0 * (1.0 - c * c) * a1;
-	b2 = (1.0 - resonance * c + c * c) * a1;
+	b1 = 2.0 * ( 1.0 - c * c) * a1;
+	b2 = ( 1.0 - resonance * c + c * c ) * a1;
 
 	// compute output value
 	out[0] = a1 * in[0] + a2 * in[-1] + a3 * in[-2] - b1 * out[-1] - b2 * out[-2];
 }
 
-void SoundFX_LowpassFast::ProcessSample(float *in, float *out)
-{
+void SoundFX_LowpassFast::ProcessSample( float* in, float* out ) {
 	// compute output value
 	out[0] = a1 * in[0] + a2 * in[-1] + a3 * in[-2] - b1 * out[-1] - b2 * out[-2];
 }
 
-void SoundFX_LowpassFast::SetParms(float p1, float p2, float p3)
-{
+void SoundFX_LowpassFast::SetParms( float p1, float p2, float p3 ) {
 	float c;
 
 	// set the vars
@@ -1605,20 +1267,19 @@ void SoundFX_LowpassFast::SetParms(float p1, float p2,
 	res = p2;
 
 	// precompute the coefs
-	c = 1.0 / idMath::Tan(idMath::PI * freq / 44100);
+	c = 1.0 / idMath::Tan( idMath::PI * freq / 44100 );
 
 	// compute coefs
-	a1 = 1.0 / (1.0 + res * c + c * c);
+	a1 = 1.0 / ( 1.0 + res * c + c * c );
 	a2 = 2* a1;
 	a3 = a1;
 
-	b1 = 2.0 * (1.0 - c * c) * a1;
-	b2 = (1.0 - res * c + c * c) * a1;
+	b1 = 2.0 * ( 1.0 - c * c) * a1;
+	b2 = ( 1.0 - res * c + c * c ) * a1;
 }
 
-void SoundFX_Comb::Initialize()
-{
-	if (initialized)
+void SoundFX_Comb::Initialize() {
+	if ( initialized )
 		return;
 
 	initialized = true;
@@ -1627,8 +1288,7 @@ void SoundFX_Comb::Initialize()
 	currentTime = 0;
 }
 
-void SoundFX_Comb::ProcessSample(float *in, float *out)
-{
+void SoundFX_Comb::ProcessSample( float* in, float* out ) {
 	float gain = idSoundSystemLocal::s_reverbFeedback.GetFloat();
 	int len = idSoundSystemLocal::s_reverbTime.GetFloat() + param;
 
@@ -1640,8 +1300,7 @@ void SoundFX_Comb::ProcessSample(float *in, float *out
 
 	// increment current time
 	currentTime++;
-
-	if (currentTime >= len)
+	if ( currentTime >= len )
 		currentTime -= len;
 }
 
@@ -1650,68 +1309,67 @@ void SoundFX_Comb::ProcessSample(float *in, float *out
 idSoundSystemLocal::DoEnviroSuit
 ===================
 */
-void idSoundSystemLocal::DoEnviroSuit(float *samples, int numSamples, int numSpeakers)
-{
+void idSoundSystemLocal::DoEnviroSuit( float* samples, int numSamples, int numSpeakers ) {
 	float out[10000], *out_p = out + 2;
 	float in[10000], *in_p = in + 2;
 
-	assert(!idSoundSystemLocal::useOpenAL);
+	// TODO port to OpenAL
+	assert( false );
 
-	if (!fxList.Num()) {
-		for (int i = 0; i < 6; i++) {
-			SoundFX *fx;
+	if ( !fxList.Num() ) {
+		for ( int i = 0; i < 6; i++ ) {
+			SoundFX* fx;
 
 			// lowpass filter
 			fx = new SoundFX_Lowpass();
-			fx->SetChannel(i);
-			fxList.Append(fx);
+			fx->SetChannel( i );
+			fxList.Append( fx );
 
 			// comb
 			fx = new SoundFX_Comb();
-			fx->SetChannel(i);
-			fx->SetParameter(i * 100);
-			fxList.Append(fx);
+			fx->SetChannel( i );
+			fx->SetParameter( i * 100 );
+			fxList.Append( fx );
 
 			// comb
 			fx = new SoundFX_Comb();
-			fx->SetChannel(i);
-			fx->SetParameter(i * 100 + 5);
-			fxList.Append(fx);
+			fx->SetChannel( i );
+			fx->SetParameter( i * 100 + 5 );
+			fxList.Append( fx );
 		}
 	}
 
-	for (int i = 0; i < numSpeakers; i++) {
+	for ( int i = 0; i < numSpeakers; i++ ) {
 		int j;
 
 		// restore previous samples
-		memset(in, 0, 10000 * sizeof(float));
-		memset(out, 0, 10000 * sizeof(float));
+		memset( in, 0, 10000 * sizeof( float ) );
+		memset( out, 0, 10000 * sizeof( float ) );
 
 		// fx loop
-		for (int k = 0; k < fxList.Num(); k++) {
-			SoundFX *fx = fxList[k];
+		for ( int k = 0; k < fxList.Num(); k++ ) {
+			SoundFX* fx = fxList[k];
 
 			// skip if we're not the right channel
-			if (fx->GetChannel() != i)
+			if ( fx->GetChannel() != i )
 				continue;
 
 			// get samples and continuity
-			fx->GetContinuitySamples(in_p[-1], in_p[-2], out_p[-1], out_p[-2]);
-
-			for (j = 0; j < numSamples; j++) {
+			fx->GetContinuitySamples( in_p[-1], in_p[-2], out_p[-1], out_p[-2] );
+			for ( j = 0; j < numSamples; j++ ) {
 				in_p[j] = samples[j * numSpeakers + i] * s_enviroSuitVolumeScale.GetFloat();
 			}
 
 			// process fx loop
-			for (j = 0; j < numSamples; j++) {
-				fx->ProcessSample(in_p + j, out_p + j);
+			for ( j = 0; j < numSamples; j++ ) {
+				fx->ProcessSample( in_p + j, out_p + j );
 			}
 
 			// store samples and continuity
-			fx->SetContinuitySamples(in_p[numSamples-2], in_p[numSamples-3], out_p[numSamples-2], out_p[numSamples-3]);
+			fx->SetContinuitySamples( in_p[numSamples-2], in_p[numSamples-3], out_p[numSamples-2], out_p[numSamples-3] );
 
-			for (j = 0; j < numSamples; j++) {
-				samples[j *numSpeakers + i] = out_p[j];
+			for ( j = 0; j < numSamples; j++ ) {
+				samples[j * numSpeakers + i] = out_p[j];
 			}
 		}
 	}
@@ -1722,55 +1380,42 @@ void idSoundSystemLocal::DoEnviroSuit(float *samples, 
 idSoundSystemLocal::PrintMemInfo
 =================
 */
-void idSoundSystemLocal::PrintMemInfo(MemInfo_t *mi)
-{
-	soundCache->PrintMemInfo(mi);
+void idSoundSystemLocal::PrintMemInfo( MemInfo_t *mi ) {
+	soundCache->PrintMemInfo( mi );
 }
 
 /*
 ===============
-idSoundSystemLocal::EAXAvailable
+idSoundSystemLocal::IsEAXAvailable
 ===============
 */
-int idSoundSystemLocal::IsEAXAvailable(void)
-{
-#if !ID_OPENAL
+int idSoundSystemLocal::IsEAXAvailable( void ) {
+#if !ID_OPENAL || !ID_OPENAL_EAX
 	return -1;
 #else
-#ifdef _OPENAL_EFX
-	return EAXAvailable;
-#else
 	ALCdevice	*device;
 	ALCcontext	*context;
 
-	if (EAXAvailable != -1) {
+	if ( EAXAvailable != -1 ) {
 		return EAXAvailable;
 	}
 
-	if (!Sys_LoadOpenAL()) {
-		EAXAvailable = 2;
-		return 2;
-	}
-
 	// when dynamically loading the OpenAL subsystem, we need to get a context before alIsExtensionPresent would work
-	device = alcOpenDevice(NULL);
-	context = alcCreateContext(device, NULL);
-	alcMakeContextCurrent(context);
-
-	if (alIsExtensionPresent(ID_ALCHAR "EAX4.0")) {
-		alcMakeContextCurrent(NULL);
-		alcDestroyContext(context);
-		alcCloseDevice(device);
+	device = alcOpenDevice( NULL );
+	context = alcCreateContext( device, NULL );
+	alcMakeContextCurrent( context );
+	if ( alIsExtensionPresent( ID_ALCHAR "EAX4.0" ) ) {
+		alcMakeContextCurrent( NULL );
+		alcDestroyContext( context );
+		alcCloseDevice( device );
 		EAXAvailable = 1;
 		return 1;
 	}
-
-	alcMakeContextCurrent(NULL);
-	alcDestroyContext(context);
-	alcCloseDevice(device);
+	alcMakeContextCurrent( NULL );
+	alcDestroyContext( context );
+	alcCloseDevice( device );
 	EAXAvailable = 0;
 	return 0;
-#endif
 #endif
 }
 
