Index: src/third_party/websocketpp/websocketpp/transport/asio/connection.hpp
--- src/third_party/websocketpp/websocketpp/transport/asio/connection.hpp.orig
+++ src/third_party/websocketpp/websocketpp/transport/asio/connection.hpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ * Copyright (c) 2015, Peter Thorson. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -37,16 +37,15 @@
 
 #include <websocketpp/base64/base64.hpp>
 #include <websocketpp/error.hpp>
+#include <websocketpp/uri.hpp>
 
+#include <websocketpp/common/asio.hpp>
+#include <websocketpp/common/chrono.hpp>
 #include <websocketpp/common/cpp11.hpp>
 #include <websocketpp/common/memory.hpp>
 #include <websocketpp/common/functional.hpp>
 #include <websocketpp/common/connection_hdl.hpp>
 
-#include <boost/asio.hpp>
-#include <boost/asio/deadline_timer.hpp>
-#include <boost/system/error_code.hpp>
-
 #include <istream>
 #include <sstream>
 #include <string>
@@ -58,10 +57,10 @@ namespace asio {
 
 typedef lib::function<void(connection_hdl)> tcp_init_handler;
 
-/// Boost Asio based connection transport component
+/// Asio based connection transport component
 /**
  * transport::asio::connection implements a connection transport component using
- * Boost ASIO that works with the transport::asio::endpoint endpoint transport
+ * Asio that works with the transport::asio::endpoint endpoint transport
  * component.
  */
 template <typename config>
@@ -86,12 +85,12 @@ class connection : public config::socket_type::socket_
     typedef typename config::response_type response_type;
     typedef typename response_type::ptr response_ptr;
 
-    /// Type of a pointer to the ASIO io_context being used
-    typedef boost::asio::io_context* io_service_ptr;
-    /// Type of a pointer to the ASIO io_context::strand being used
-    typedef lib::shared_ptr<boost::asio::io_context::strand> strand_ptr;
-    /// Type of a pointer to the ASIO timer class
-    typedef lib::shared_ptr<boost::asio::deadline_timer> timer_ptr;
+    /// Type of a pointer to the Asio io_context being used
+    typedef lib::asio::io_context * io_context_ptr;
+    /// Type of a pointer to the Asio io_context::strand being used
+    typedef lib::shared_ptr<lib::asio::io_context::strand> strand_ptr;
+    /// Type of a pointer to the Asio timer class
+    typedef lib::shared_ptr<lib::asio::steady_timer> timer_ptr;
 
     // connection is friends with its associated endpoint to allow the endpoint
     // to call private/protected utility methods that we don't want to expose
@@ -99,12 +98,12 @@ class connection : public config::socket_type::socket_
     friend class endpoint<config>;
 
     // generate and manage our own io_context
-    explicit connection(bool is_server, alog_type& alog, elog_type& elog)
+    explicit connection(bool is_server, const lib::shared_ptr<alog_type> & alog, const lib::shared_ptr<elog_type> & elog)
       : m_is_server(is_server)
       , m_alog(alog)
       , m_elog(elog)
     {
-        m_alog.write(log::alevel::devel,"asio con transport constructor");
+        m_alog->write(log::alevel::devel,"asio con transport constructor");
     }
 
     /// Get a shared pointer to this component
@@ -116,6 +115,22 @@ class connection : public config::socket_type::socket_
         return socket_con_type::is_secure();
     }
 
+    /// Set uri hook
+    /**
+     * Called by the endpoint as a connection is being established to provide
+     * the uri being connected to to the transport layer.
+     *
+     * This transport policy doesn't use the uri except to forward it to the 
+     * socket layer.
+     *
+     * @since 0.6.0
+     *
+     * @param u The uri to set
+     */
+    void set_uri(uri_ptr u) {
+        socket_con_type::set_uri(u);
+    }
+
     /// Sets the tcp pre init handler
     /**
      * The tcp pre init handler is called after the raw tcp connection has been
@@ -269,7 +284,7 @@ class connection : public config::socket_type::socket_
         std::string ret = socket_con_type::get_remote_endpoint(ec);
 
         if (ec) {
-            m_elog.write(log::elevel::info,ret);
+            m_elog->write(log::elevel::info,ret);
             return "Unknown";
         } else {
             return ret;
@@ -296,10 +311,14 @@ class connection : public config::socket_type::socket_
      * needed.
      */
     timer_ptr set_timer(long duration, timer_handler callback) {
-        timer_ptr new_timer = lib::make_shared<boost::asio::deadline_timer>(*m_io_service, boost::posix_time::milliseconds(duration));
+        timer_ptr new_timer(
+            new lib::asio::steady_timer(
+                *m_io_context,
+                lib::asio::milliseconds(duration))
+        );
 
         if (config::enable_multithreading) {
-            new_timer->async_wait(m_strand->wrap(lib::bind(
+            new_timer->async_wait(lib::asio::bind_executor(*m_strand, lib::bind(
                 &type::handle_timer, get_shared(),
                 new_timer,
                 callback,
@@ -329,10 +348,10 @@ class connection : public config::socket_type::socket_
      * @param ec The status code
      */
     void handle_timer(timer_ptr, timer_handler callback,
-        boost::system::error_code const & ec)
+        lib::asio::error_code const & ec)
     {
         if (ec) {
-            if (ec == boost::asio::error::operation_aborted) {
+            if (ec == lib::asio::error::operation_aborted) {
                 callback(make_error_code(transport::error::operation_aborted));
             } else {
                 log_err(log::elevel::info,"asio handle_timer",ec);
@@ -342,16 +361,39 @@ class connection : public config::socket_type::socket_
             callback(lib::error_code());
         }
     }
-protected:
+
     /// Get a pointer to this connection's strand
     strand_ptr get_strand() {
         return m_strand;
     }
 
+    /// Get the internal transport error code for a closed/failed connection
+    /**
+     * Retrieves a machine readable detailed error code indicating the reason
+     * that the connection was closed or failed. Valid only after the close or
+     * fail handler is called.
+     *
+     * Primarily used if you are using mismatched asio / system_error
+     * implementations such as `boost::asio` with `std::system_error`. In these
+     * cases the transport error type is different than the library error type
+     * and some WebSocket++ functions that return transport errors via the 
+     * library error code type will be coerced into a catch all `pass_through`
+     * or `tls_error` error. This method will return the original machine 
+     * readable transport error in the native type.
+     *
+     * @since 0.7.0
+     *
+     * @return Error code indicating the reason the connection was closed or 
+     * failed
+     */
+    lib::asio::error_code get_transport_ec() const {
+        return m_tec;
+    }
+
     /// Initialize transport for reading
     /**
      * init_asio is called once immediately after construction to initialize
-     * boost::asio components to the io_context
+     * Asio components to the io_context
      *
      * The transport initialization sequence consists of the following steps:
      * - Pre-init: the underlying socket is initialized to the point where
@@ -365,20 +407,20 @@ class connection : public config::socket_type::socket_
      * read or write the WebSocket handshakes. At this point the original
      * callback function is called.
      */
+protected:
     void init(init_handler callback) {
-        if (m_alog.static_test(log::alevel::devel)) {
-            m_alog.write(log::alevel::devel,"asio connection init");
+        if (m_alog->static_test(log::alevel::devel)) {
+            m_alog->write(log::alevel::devel,"asio connection init");
         }
 
         // TODO: pre-init timeout. Right now no implemented socket policies
         // actually have an asyncronous pre-init
 
-        m_init_handler = callback;
-
         socket_con_type::pre_init(
             lib::bind(
                 &type::handle_pre_init,
                 get_shared(),
+                callback,
                 lib::placeholders::_1
             )
         );
@@ -409,50 +451,29 @@ class connection : public config::socket_type::socket_
     /// Finish constructing the transport
     /**
      * init_asio is called once immediately after construction to initialize
-     * boost::asio components to the io_context.
+     * Asio components to the io_context.
      *
      * @param io_context A pointer to the io_context to register with this
      * connection
      *
      * @return Status code for the success or failure of the initialization
      */
-    lib::error_code init_asio (io_service_ptr io_context) {
-        m_io_service = io_context;
+    lib::error_code init_asio (io_context_ptr io_context) {
+        m_io_context = io_context;
 
         if (config::enable_multithreading) {
-            m_strand = lib::make_shared<boost::asio::io_context::strand>(*io_context);
-
-            m_async_read_handler = m_strand->wrap(lib::bind(
-                &type::handle_async_read, get_shared(),lib::placeholders::_1,
-                lib::placeholders::_2));
-
-            m_async_write_handler = m_strand->wrap(lib::bind(
-                &type::handle_async_write, get_shared(),lib::placeholders::_1,
-                lib::placeholders::_2));
-        } else {
-            m_async_read_handler = lib::bind(&type::handle_async_read,
-                get_shared(), lib::placeholders::_1, lib::placeholders::_2);
-
-            m_async_write_handler = lib::bind(&type::handle_async_write,
-                get_shared(), lib::placeholders::_1, lib::placeholders::_2);
+            m_strand.reset(new lib::asio::io_context::strand(*io_context));
         }
 
         lib::error_code ec = socket_con_type::init_asio(io_context, m_strand,
             m_is_server);
 
-        if (ec) {
-            // reset the handlers to break the circular reference:
-            // this->handler->this
-            lib::clear_function(m_async_read_handler);
-            lib::clear_function(m_async_write_handler);
-        }
-
         return ec;
     }
 
-    void handle_pre_init(lib::error_code const & ec) {
-        if (m_alog.static_test(log::alevel::devel)) {
-            m_alog.write(log::alevel::devel,"asio connection handle pre_init");
+    void handle_pre_init(init_handler callback, lib::error_code const & ec) {
+        if (m_alog->static_test(log::alevel::devel)) {
+            m_alog->write(log::alevel::devel,"asio connection handle pre_init");
         }
 
         if (m_tcp_pre_init_handler) {
@@ -460,21 +481,21 @@ class connection : public config::socket_type::socket_
         }
 
         if (ec) {
-            m_init_handler(ec);
+            callback(ec);
         }
 
         // If we have a proxy set issue a proxy connect, otherwise skip to
         // post_init
         if (!m_proxy.empty()) {
-            proxy_write();
+            proxy_write(callback);
         } else {
-            post_init();
+            post_init(callback);
         }
     }
 
-    void post_init() {
-        if (m_alog.static_test(log::alevel::devel)) {
-            m_alog.write(log::alevel::devel,"asio connection post_init");
+    void post_init(init_handler callback) {
+        if (m_alog->static_test(log::alevel::devel)) {
+            m_alog->write(log::alevel::devel,"asio connection post_init");
         }
 
         timer_ptr post_timer;
@@ -486,7 +507,7 @@ class connection : public config::socket_type::socket_
                     &type::handle_post_init_timeout,
                     get_shared(),
                     post_timer,
-                    m_init_handler,
+                    callback,
                     lib::placeholders::_1
                 )
             );
@@ -497,7 +518,7 @@ class connection : public config::socket_type::socket_
                 &type::handle_post_init,
                 get_shared(),
                 post_timer,
-                m_init_handler,
+                callback,
                 lib::placeholders::_1
             )
         );
@@ -519,7 +540,7 @@ class connection : public config::socket_type::socket_
 
         if (ec) {
             if (ec == transport::error::operation_aborted) {
-                m_alog.write(log::alevel::devel,
+                m_alog->write(log::alevel::devel,
                     "asio post init timer cancelled");
                 return;
             }
@@ -534,8 +555,8 @@ class connection : public config::socket_type::socket_
             }
         }
 
-        m_alog.write(log::alevel::devel,"Asio transport post-init timed out");
-        socket_con_type::cancel_socket();
+        m_alog->write(log::alevel::devel, "Asio transport post-init timed out");
+        cancel_socket_checked();
         callback(ret_ec);
     }
 
@@ -552,9 +573,9 @@ class connection : public config::socket_type::socket_
         lib::error_code const & ec)
     {
         if (ec == transport::error::operation_aborted ||
-            (post_timer && post_timer->expires_from_now().is_negative()))
+            (post_timer && lib::asio::is_neg(post_timer->expiry() - timer_ptr::element_type::clock_type::now())))
         {
-            m_alog.write(log::alevel::devel,"post_init cancelled");
+            m_alog->write(log::alevel::devel,"post_init cancelled");
             return;
         }
 
@@ -562,8 +583,8 @@ class connection : public config::socket_type::socket_
             post_timer->cancel();
         }
 
-        if (m_alog.static_test(log::alevel::devel)) {
-            m_alog.write(log::alevel::devel,"asio connection handle_post_init");
+        if (m_alog->static_test(log::alevel::devel)) {
+            m_alog->write(log::alevel::devel,"asio connection handle_post_init");
         }
 
         if (m_tcp_post_init_handler) {
@@ -573,24 +594,24 @@ class connection : public config::socket_type::socket_
         callback(ec);
     }
 
-    void proxy_write() {
-        if (m_alog.static_test(log::alevel::devel)) {
-            m_alog.write(log::alevel::devel,"asio connection proxy_write");
+    void proxy_write(init_handler callback) {
+        if (m_alog->static_test(log::alevel::devel)) {
+            m_alog->write(log::alevel::devel,"asio connection proxy_write");
         }
 
         if (!m_proxy_data) {
-            m_elog.write(log::elevel::library,
+            m_elog->write(log::elevel::library,
                 "assertion failed: !m_proxy_data in asio::connection::proxy_write");
-            m_init_handler(make_error_code(error::general));
+            callback(make_error_code(error::general));
             return;
         }
 
         m_proxy_data->write_buf = m_proxy_data->req.raw();
 
-        m_bufs.push_back(boost::asio::buffer(m_proxy_data->write_buf.data(),
-                                             m_proxy_data->write_buf.size()));
+        m_bufs.push_back(lib::asio::buffer(m_proxy_data->write_buf.data(),
+                                           m_proxy_data->write_buf.size()));
 
-        m_alog.write(log::alevel::devel,m_proxy_data->write_buf);
+        m_alog->write(log::alevel::devel,m_proxy_data->write_buf);
 
         // Set a timer so we don't wait forever for the proxy to respond
         m_proxy_data->timer = this->set_timer(
@@ -598,29 +619,29 @@ class connection : public config::socket_type::socket_
             lib::bind(
                 &type::handle_proxy_timeout,
                 get_shared(),
-                m_init_handler,
+                callback,
                 lib::placeholders::_1
             )
         );
 
         // Send proxy request
         if (config::enable_multithreading) {
-            boost::asio::async_write(
+            lib::asio::async_write(
                 socket_con_type::get_next_layer(),
                 m_bufs,
-                m_strand->wrap(lib::bind(
+                lib::asio::bind_executor(*m_strand, lib::bind(
                     &type::handle_proxy_write, get_shared(),
-                    m_init_handler,
+                    callback,
                     lib::placeholders::_1
                 ))
             );
         } else {
-            boost::asio::async_write(
+            lib::asio::async_write(
                 socket_con_type::get_next_layer(),
                 m_bufs,
                 lib::bind(
                     &type::handle_proxy_write, get_shared(),
-                    m_init_handler,
+                    callback,
                     lib::placeholders::_1
                 )
             );
@@ -630,25 +651,25 @@ class connection : public config::socket_type::socket_
     void handle_proxy_timeout(init_handler callback, lib::error_code const & ec)
     {
         if (ec == transport::error::operation_aborted) {
-            m_alog.write(log::alevel::devel,
+            m_alog->write(log::alevel::devel,
                 "asio handle_proxy_write timer cancelled");
             return;
         } else if (ec) {
             log_err(log::elevel::devel,"asio handle_proxy_write",ec);
             callback(ec);
         } else {
-            m_alog.write(log::alevel::devel,
+            m_alog->write(log::alevel::devel,
                 "asio handle_proxy_write timer expired");
-            socket_con_type::cancel_socket();
+            cancel_socket_checked();
             callback(make_error_code(transport::error::timeout));
         }
     }
 
     void handle_proxy_write(init_handler callback,
-        boost::system::error_code const & ec)
+        lib::asio::error_code const & ec)
     {
-        if (m_alog.static_test(log::alevel::devel)) {
-            m_alog.write(log::alevel::devel,
+        if (m_alog->static_test(log::alevel::devel)) {
+            m_alog->write(log::alevel::devel,
                 "asio connection handle_proxy_write");
         }
 
@@ -657,10 +678,10 @@ class connection : public config::socket_type::socket_
         // Timer expired or the operation was aborted for some reason.
         // Whatever aborted it will be issuing the callback so we are safe to
         // return
-        if (ec == boost::asio::error::operation_aborted ||
-            m_proxy_data->timer->expires_from_now().is_negative())
+        if (ec == lib::asio::error::operation_aborted ||
+            lib::asio::is_neg(m_proxy_data->timer->expiry() - timer_ptr::element_type::clock_type::now()))
         {
-            m_elog.write(log::elevel::devel,"write operation aborted");
+            m_elog->write(log::elevel::devel,"write operation aborted");
             return;
         }
 
@@ -675,12 +696,12 @@ class connection : public config::socket_type::socket_
     }
 
     void proxy_read(init_handler callback) {
-        if (m_alog.static_test(log::alevel::devel)) {
-            m_alog.write(log::alevel::devel,"asio connection proxy_read");
+        if (m_alog->static_test(log::alevel::devel)) {
+            m_alog->write(log::alevel::devel,"asio connection proxy_read");
         }
 
         if (!m_proxy_data) {
-            m_elog.write(log::elevel::library,
+            m_elog->write(log::elevel::library,
                 "assertion failed: !m_proxy_data in asio::connection::proxy_read");
             m_proxy_data->timer->cancel();
             callback(make_error_code(error::general));
@@ -688,18 +709,18 @@ class connection : public config::socket_type::socket_
         }
 
         if (config::enable_multithreading) {
-            boost::asio::async_read_until(
+            lib::asio::async_read_until(
                 socket_con_type::get_next_layer(),
                 m_proxy_data->read_buf,
                 "\r\n\r\n",
-                m_strand->wrap(lib::bind(
+                lib::asio::bind_executor(*m_strand, lib::bind(
                     &type::handle_proxy_read, get_shared(),
                     callback,
                     lib::placeholders::_1, lib::placeholders::_2
                 ))
             );
         } else {
-            boost::asio::async_read_until(
+            lib::asio::async_read_until(
                 socket_con_type::get_next_layer(),
                 m_proxy_data->read_buf,
                 "\r\n\r\n",
@@ -719,20 +740,20 @@ class connection : public config::socket_type::socket_
      * @param bytes_transferred The number of bytes read
      */
     void handle_proxy_read(init_handler callback,
-        boost::system::error_code const & ec, size_t)
+        lib::asio::error_code const & ec, size_t)
     {
-        if (m_alog.static_test(log::alevel::devel)) {
-            m_alog.write(log::alevel::devel,
+        if (m_alog->static_test(log::alevel::devel)) {
+            m_alog->write(log::alevel::devel,
                 "asio connection handle_proxy_read");
         }
 
         // Timer expired or the operation was aborted for some reason.
         // Whatever aborted it will be issuing the callback so we are safe to
         // return
-        if (ec == boost::asio::error::operation_aborted ||
-            m_proxy_data->timer->expires_from_now().is_negative())
+        if (ec == lib::asio::error::operation_aborted ||
+            lib::asio::is_neg(m_proxy_data->timer->expiry() - timer_ptr::element_type::clock_type::now()))
         {
-            m_elog.write(log::elevel::devel,"read operation aborted");
+            m_elog->write(log::elevel::devel,"read operation aborted");
             return;
         }
 
@@ -740,12 +761,12 @@ class connection : public config::socket_type::socket_
         m_proxy_data->timer->cancel();
 
         if (ec) {
-            m_elog.write(log::elevel::info,
+            m_elog->write(log::elevel::info,
                 "asio handle_proxy_read error: "+ec.message());
             callback(make_error_code(error::pass_through));
         } else {
             if (!m_proxy_data) {
-                m_elog.write(log::elevel::library,
+                m_elog->write(log::elevel::library,
                     "assertion failed: !m_proxy_data in asio::connection::handle_proxy_read");
                 callback(make_error_code(error::general));
                 return;
@@ -762,7 +783,7 @@ class connection : public config::socket_type::socket_
                 return;
             }
 
-            m_alog.write(log::alevel::devel,m_proxy_data->res.raw());
+            m_alog->write(log::alevel::devel,m_proxy_data->res.raw());
 
             if (m_proxy_data->res.get_status_code() != http::status_code::ok) {
                 // got an error response back
@@ -774,7 +795,7 @@ class connection : public config::socket_type::socket_
                   << " ("
                   << m_proxy_data->res.get_status_msg()
                   << ")";
-                m_elog.write(log::elevel::info,s.str());
+                m_elog->write(log::elevel::info,s.str());
                 callback(make_error_code(error::proxy_failed));
                 return;
             }
@@ -791,72 +812,76 @@ class connection : public config::socket_type::socket_
             m_proxy_data.reset();
 
             // Continue with post proxy initialization
-            post_init();
+            post_init(callback);
         }
     }
 
     /// read at least num_bytes bytes into buf and then call handler.
-    /**
-     *
-     *
-     */
     void async_read_at_least(size_t num_bytes, char *buf, size_t len,
         read_handler handler)
     {
-        if (m_alog.static_test(log::alevel::devel)) {
+        if (m_alog->static_test(log::alevel::devel)) {
             std::stringstream s;
             s << "asio async_read_at_least: " << num_bytes;
-            m_alog.write(log::alevel::devel,s.str());
+            m_alog->write(log::alevel::devel,s.str());
         }
 
-        if (!m_async_read_handler) {
-            m_alog.write(log::alevel::devel,
-                "async_read_at_least called after async_shutdown");
-            handler(make_error_code(transport::error::action_after_shutdown),0);
-            return;
-        }
-
         // TODO: safety vs speed ?
         // maybe move into an if devel block
         /*if (num_bytes > len) {
-            m_elog.write(log::elevel::devel,
+            m_elog->write(log::elevel::devel,
                 "asio async_read_at_least error::invalid_num_bytes");
             handler(make_error_code(transport::error::invalid_num_bytes),
                 size_t(0));
             return;
         }*/
 
-        m_read_handler = handler;
-
-        if (!m_read_handler) {
-            m_alog.write(log::alevel::devel,
-                "asio con async_read_at_least called with bad handler");
+        if (config::enable_multithreading) {
+            lib::asio::async_read(
+                socket_con_type::get_socket(),
+                lib::asio::buffer(buf,len),
+                lib::asio::transfer_at_least(num_bytes),
+                lib::asio::bind_executor(*m_strand, make_custom_alloc_handler(
+                    m_read_handler_allocator,
+                    lib::bind(
+                        &type::handle_async_read, get_shared(),
+                        handler,
+                        lib::placeholders::_1, lib::placeholders::_2
+                    )
+                ))
+            );
+        } else {
+            lib::asio::async_read(
+                socket_con_type::get_socket(),
+                lib::asio::buffer(buf,len),
+                lib::asio::transfer_at_least(num_bytes),
+                make_custom_alloc_handler(
+                    m_read_handler_allocator,
+                    lib::bind(
+                        &type::handle_async_read, get_shared(),
+                        handler,
+                        lib::placeholders::_1, lib::placeholders::_2
+                    )
+                )
+            );    
         }
-
-        boost::asio::async_read(
-            socket_con_type::get_socket(),
-            boost::asio::buffer(buf,len),
-            boost::asio::transfer_at_least(num_bytes),
-            make_custom_alloc_handler(
-                m_read_handler_allocator,
-                m_async_read_handler
-            )
-        );
+        
     }
 
-    void handle_async_read(boost::system::error_code const & ec,
+    void handle_async_read(read_handler handler, lib::asio::error_code const & ec,
         size_t bytes_transferred)
     {
-        m_alog.write(log::alevel::devel, "asio con handle_async_read");
+        m_alog->write(log::alevel::devel, "asio con handle_async_read");
 
-        // translate boost error codes into more lib::error_codes
+        // translate asio error codes into more lib::error_codes
         lib::error_code tec;
-        if (ec == boost::asio::error::eof) {
+        if (ec == lib::asio::error::eof) {
             tec = make_error_code(transport::error::eof);
         } else if (ec) {
             // We don't know much more about the error at this point. As our
             // socket/security policy if it knows more:
             tec = socket_con_type::translate_ec(ec);
+            m_tec = ec;
 
             if (tec == transport::error::tls_error ||
                 tec == transport::error::pass_through)
@@ -867,63 +892,84 @@ class connection : public config::socket_type::socket_
                 log_err(log::elevel::info,"asio async_read_at_least",ec);
             }
         }
-        if (m_read_handler) {
-            m_read_handler(tec,bytes_transferred);
-            // TODO: why does this line break things?
-            //m_read_handler = _WEBSOCKETPP_NULL_FUNCTION_;
+        if (handler) {
+            handler(tec,bytes_transferred);
         } else {
             // This can happen in cases where the connection is terminated while
             // the transport is waiting on a read.
-            m_alog.write(log::alevel::devel,
+            m_alog->write(log::alevel::devel,
                 "handle_async_read called with null read handler");
         }
     }
 
+    /// Initiate a potentially asyncronous write of the given buffer
     void async_write(const char* buf, size_t len, write_handler handler) {
-        if (!m_async_write_handler) {
-            m_alog.write(log::alevel::devel,
-                "async_write (single) called after async_shutdown");
-            handler(make_error_code(transport::error::action_after_shutdown));
-            return;
-        }
+        m_bufs.push_back(lib::asio::buffer(buf,len));
 
-        m_bufs.push_back(boost::asio::buffer(buf,len));
-
-        m_write_handler = handler;
-
-        boost::asio::async_write(
-            socket_con_type::get_socket(),
-            m_bufs,
-            make_custom_alloc_handler(
-                m_write_handler_allocator,
-                m_async_write_handler
-            )
-        );
+        if (config::enable_multithreading) {
+            lib::asio::async_write(
+                socket_con_type::get_socket(),
+                m_bufs,
+                lib::asio::bind_executor(*m_strand, make_custom_alloc_handler(
+                    m_write_handler_allocator,
+                    lib::bind(
+                        &type::handle_async_write, get_shared(),
+                        handler,
+                        lib::placeholders::_1, lib::placeholders::_2
+                    )
+                ))
+            );
+        } else {
+            lib::asio::async_write(
+                socket_con_type::get_socket(),
+                m_bufs,
+                make_custom_alloc_handler(
+                    m_write_handler_allocator,
+                    lib::bind(
+                        &type::handle_async_write, get_shared(),
+                        handler,
+                        lib::placeholders::_1, lib::placeholders::_2
+                    )
+                )
+            );
+        }
     }
 
+    /// Initiate a potentially asyncronous write of the given buffers
     void async_write(std::vector<buffer> const & bufs, write_handler handler) {
-        if (!m_async_write_handler) {
-            m_alog.write(log::alevel::devel,
-                "async_write (vector) called after async_shutdown");
-            handler(make_error_code(transport::error::action_after_shutdown));
-            return;
-        }
         std::vector<buffer>::const_iterator it;
 
         for (it = bufs.begin(); it != bufs.end(); ++it) {
-            m_bufs.push_back(boost::asio::buffer((*it).buf,(*it).len));
+            m_bufs.push_back(lib::asio::buffer((*it).buf,(*it).len));
         }
 
-        m_write_handler = handler;
-
-        boost::asio::async_write(
-            socket_con_type::get_socket(),
-            m_bufs,
-            make_custom_alloc_handler(
-                m_write_handler_allocator,
-                m_async_write_handler
-            )
-        );
+        if (config::enable_multithreading) {
+            lib::asio::async_write(
+                socket_con_type::get_socket(),
+                m_bufs,
+                lib::asio::bind_executor(*m_strand, make_custom_alloc_handler(
+                    m_write_handler_allocator,
+                    lib::bind(
+                        &type::handle_async_write, get_shared(),
+                        handler,
+                        lib::placeholders::_1, lib::placeholders::_2
+                    )
+                ))
+            );
+        } else {
+            lib::asio::async_write(
+                socket_con_type::get_socket(),
+                m_bufs,
+                make_custom_alloc_handler(
+                    m_write_handler_allocator,
+                    lib::bind(
+                        &type::handle_async_write, get_shared(),
+                        handler,
+                        lib::placeholders::_1, lib::placeholders::_2
+                    )
+                )
+            );
+        }
     }
 
     /// Async write callback
@@ -931,21 +977,19 @@ class connection : public config::socket_type::socket_
      * @param ec The status code
      * @param bytes_transferred The number of bytes read
      */
-    void handle_async_write(boost::system::error_code const & ec, size_t) {
+    void handle_async_write(write_handler handler, lib::asio::error_code const & ec, size_t) {
         m_bufs.clear();
         lib::error_code tec;
         if (ec) {
             log_err(log::elevel::info,"asio async_write",ec);
             tec = make_error_code(transport::error::pass_through);
         }
-        if (m_write_handler) {
-            m_write_handler(tec);
-            // TODO: why does this line break things?
-            //m_write_handler = _WEBSOCKETPP_NULL_FUNCTION_;
+        if (handler) {
+            handler(tec);
         } else {
             // This can happen in cases where the connection is terminated while
             // the transport is waiting on a read.
-            m_alog.write(log::alevel::devel,
+            m_alog->write(log::alevel::devel,
                 "handle_async_write called with null write handler");
         }
     }
@@ -968,18 +1012,18 @@ class connection : public config::socket_type::socket_
      */
     lib::error_code interrupt(interrupt_handler handler) {
         if (config::enable_multithreading) {
-            boost::asio::post(*m_io_service, m_strand->wrap(handler));
+            lib::asio::post(m_io_context->get_executor(), lib::asio::bind_executor(*m_strand, handler));
         } else {
-            boost::asio::post(*m_io_service, handler);
+            lib::asio::post(m_io_context->get_executor(), handler);
         }
         return lib::error_code();
     }
 
     lib::error_code dispatch(dispatch_handler handler) {
         if (config::enable_multithreading) {
-            boost::asio::post(*m_io_service, m_strand->wrap(handler));
+            lib::asio::post(m_io_context->get_executor(), lib::asio::bind_executor(*m_strand, handler));
         } else {
-            boost::asio::post(*m_io_service, handler);
+            lib::asio::post(m_io_context->get_executor(), handler);
         }
         return lib::error_code();
     }
@@ -990,20 +1034,10 @@ class connection : public config::socket_type::socket_
 
     /// close and clean up the underlying socket
     void async_shutdown(shutdown_handler callback) {
-        if (m_alog.static_test(log::alevel::devel)) {
-            m_alog.write(log::alevel::devel,"asio connection async_shutdown");
+        if (m_alog->static_test(log::alevel::devel)) {
+            m_alog->write(log::alevel::devel,"asio connection async_shutdown");
         }
 
-        // Reset cached handlers now that we won't be reading or writing anymore
-        // These cached handlers store shared pointers to this connection and
-        // will leak the connection if not destroyed.
-        lib::clear_function(m_async_read_handler);
-        lib::clear_function(m_async_write_handler);
-        lib::clear_function(m_init_handler);
-
-        lib::clear_function(m_read_handler);
-        lib::clear_function(m_write_handler);
-
         timer_ptr shutdown_timer;
         shutdown_timer = set_timer(
             config::timeout_socket_shutdown,
@@ -1040,7 +1074,7 @@ class connection : public config::socket_type::socket_
 
         if (ec) {
             if (ec == transport::error::operation_aborted) {
-                m_alog.write(log::alevel::devel,
+                m_alog->write(log::alevel::devel,
                     "asio socket shutdown timer cancelled");
                 return;
             }
@@ -1051,19 +1085,19 @@ class connection : public config::socket_type::socket_
             ret_ec = make_error_code(transport::error::timeout);
         }
 
-        m_alog.write(log::alevel::devel,
+        m_alog->write(log::alevel::devel,
             "Asio transport socket shutdown timed out");
-        socket_con_type::cancel_socket();
+        cancel_socket_checked();
         callback(ret_ec);
     }
 
     void handle_async_shutdown(timer_ptr shutdown_timer, shutdown_handler
-        callback, boost::system::error_code const & ec)
+        callback, lib::asio::error_code const & ec)
     {
-        if (ec == boost::asio::error::operation_aborted ||
-            shutdown_timer->expires_from_now().is_negative())
+        if (ec == lib::asio::error::operation_aborted ||
+            lib::asio::is_neg(shutdown_timer->expiry() - timer_ptr::element_type::clock_type::now()))
         {
-            m_alog.write(log::alevel::devel,"async_shutdown cancelled");
+            m_alog->write(log::alevel::devel,"async_shutdown cancelled");
             return;
         }
 
@@ -1071,7 +1105,7 @@ class connection : public config::socket_type::socket_
 
         lib::error_code tec;
         if (ec) {
-            if (ec == boost::asio::error::not_connected) {
+            if (ec == lib::asio::error::not_connected) {
                 // The socket was already closed when we tried to close it. This
                 // happens periodically (usually if a read or write fails
                 // earlier and if it is a real error will be caught at another
@@ -1080,40 +1114,48 @@ class connection : public config::socket_type::socket_
                 // We don't know anything more about this error, give our
                 // socket/security policy a crack at it.
                 tec = socket_con_type::translate_ec(ec);
+                m_tec = ec;
 
-                if (tec == transport::error::tls_short_read) {
-                    // TLS short read at this point is somewhat expected if both
-                    // sides try and end the connection at the same time or if
-                    // SSLv2 is being used. In general there is nothing that can
-                    // be done here other than a low level development log.
-                } else {
-                    // all other errors are effectively pass through errors of
-                    // some sort so print some detail on the info channel for
-                    // library users to look up if needed.
-                    log_err(log::elevel::info,"asio async_shutdown",ec);
-                }
+                // all other errors are effectively pass through errors of
+				// some sort so print some detail on the info channel for
+				// library users to look up if needed.
+				log_err(log::elevel::info,"asio async_shutdown",ec);
             }
         } else {
-            if (m_alog.static_test(log::alevel::devel)) {
-                m_alog.write(log::alevel::devel,
+            if (m_alog->static_test(log::alevel::devel)) {
+                m_alog->write(log::alevel::devel,
                     "asio con handle_async_shutdown");
             }
         }
         callback(tec);
     }
+
+    /// Cancel the underlying socket and log any errors
+    void cancel_socket_checked() {
+        lib::asio::error_code cec = socket_con_type::cancel_socket();
+        if (cec) {
+            if (cec == lib::asio::error::operation_not_supported) {
+                // cancel not supported on this OS, ignore and log at dev level
+                m_alog->write(log::alevel::devel, "socket cancel not supported");
+            } else {
+                log_err(log::elevel::warn, "socket cancel failed", cec);
+            }
+        }
+    }
+
 private:
     /// Convenience method for logging the code and message for an error_code
     template <typename error_type>
     void log_err(log::level l, const char * msg, const error_type & ec) {
         std::stringstream s;
         s << msg << " error: " << ec << " (" << ec.message() << ")";
-        m_elog.write(l,s.str());
+        m_elog->write(l,s.str());
     }
 
     // static settings
     const bool m_is_server;
-    alog_type& m_alog;
-    elog_type& m_elog;
+    lib::shared_ptr<alog_type> m_alog;
+    lib::shared_ptr<elog_type> m_elog;
 
     struct proxy_data {
         proxy_data() : timeout_proxy(config::timeout_proxy) {}
@@ -1121,7 +1163,7 @@ class connection : public config::socket_type::socket_
         request_type req;
         response_type res;
         std::string write_buf;
-        boost::asio::streambuf read_buf;
+        lib::asio::streambuf read_buf;
         long timeout_proxy;
         timer_ptr timer;
     };
@@ -1130,25 +1172,21 @@ class connection : public config::socket_type::socket_
     lib::shared_ptr<proxy_data> m_proxy_data;
 
     // transport resources
-    io_service_ptr  m_io_service;
+    io_context_ptr  m_io_context;
     strand_ptr      m_strand;
     connection_hdl  m_connection_hdl;
 
-    std::vector<boost::asio::const_buffer> m_bufs;
+    std::vector<lib::asio::const_buffer> m_bufs;
 
+    /// Detailed internal error code
+    lib::asio::error_code m_tec;
+
     // Handlers
     tcp_init_handler    m_tcp_pre_init_handler;
     tcp_init_handler    m_tcp_post_init_handler;
 
     handler_allocator   m_read_handler_allocator;
     handler_allocator   m_write_handler_allocator;
-
-    read_handler        m_read_handler;
-    write_handler       m_write_handler;
-    init_handler        m_init_handler;
-
-    async_read_handler  m_async_read_handler;
-    async_write_handler m_async_write_handler;
 };
 
 
