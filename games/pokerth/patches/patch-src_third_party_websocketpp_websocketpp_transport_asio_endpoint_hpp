Index: src/third_party/websocketpp/websocketpp/transport/asio/endpoint.hpp
--- src/third_party/websocketpp/websocketpp/transport/asio/endpoint.hpp.orig
+++ src/third_party/websocketpp/websocketpp/transport/asio/endpoint.hpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ * Copyright (c) 2015, Peter Thorson. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -35,12 +35,9 @@
 #include <websocketpp/uri.hpp>
 #include <websocketpp/logger/levels.hpp>
 
+#include <websocketpp/common/asio.hpp>
 #include <websocketpp/common/functional.hpp>
 
-#include <boost/asio.hpp>
-#include <boost/bind/bind.hpp>
-#include <boost/system/error_code.hpp>
-
 #include <sstream>
 #include <string>
 
@@ -48,10 +45,10 @@ namespace websocketpp {
 namespace transport {
 namespace asio {
 
-/// Boost Asio based endpoint transport component
+/// Asio based endpoint transport component
 /**
  * transport::asio::endpoint implements an endpoint transport component using
- * Boost ASIO.
+ * Asio.
  */
 template <typename config>
 class endpoint : public config::socket_type {
@@ -81,21 +78,24 @@ class endpoint : public config::socket_type { (public)
     typedef typename transport_con_type::ptr transport_con_ptr;
 
     /// Type of a pointer to the ASIO io_context being used
-    typedef boost::asio::io_context* io_service_ptr;
+    typedef lib::asio::io_context * io_context_ptr;
     /// Type of a shared pointer to the acceptor being used
-    typedef lib::shared_ptr<boost::asio::ip::tcp::acceptor> acceptor_ptr;
+    typedef lib::shared_ptr<lib::asio::ip::tcp::acceptor> acceptor_ptr;
     /// Type of a shared pointer to the resolver being used
-    typedef lib::shared_ptr<boost::asio::ip::tcp::resolver> resolver_ptr;
+    typedef lib::shared_ptr<lib::asio::ip::tcp::resolver> resolver_ptr;
     /// Type of timer handle
-    typedef lib::shared_ptr<boost::asio::deadline_timer> timer_ptr;
+    typedef lib::shared_ptr<lib::asio::steady_timer> timer_ptr;
     /// Type of a shared pointer to an io_context work object
-    typedef lib::shared_ptr<boost::asio::executor_work_guard<boost::asio::io_context::executor_type>> work_ptr;
+    typedef lib::shared_ptr<lib::asio::executor_work_guard<lib::asio::io_context::executor_type>> work_guard_ptr;
 
+    /// Type of socket pre-bind handler
+    typedef lib::function<lib::error_code(acceptor_ptr)> tcp_pre_bind_handler;
+
     // generate and manage our own io_context
     explicit endpoint()
-      : m_io_service(NULL)
-      , m_external_io_service(false)
-      , m_listen_backlog(0)
+      : m_io_context(NULL)
+      , m_external_io_context(false)
+      , m_listen_backlog(lib::asio::socket_base::max_listen_connections)
       , m_reuse_addr(false)
       , m_state(UNINITIALIZED)
     {
@@ -104,73 +104,85 @@ class endpoint : public config::socket_type { (public)
 
     ~endpoint() {
         // clean up our io_context if we were initialized with an internal one.
+
+        // Explicitly destroy local objects
         m_acceptor.reset();
-        if (m_state != UNINITIALIZED && !m_external_io_service) {
-            delete m_io_service;
+        m_resolver.reset();
+        m_work_guard.reset();
+        if (m_state != UNINITIALIZED && !m_external_io_context) {
+            delete m_io_context;
         }
     }
 
     /// transport::asio objects are moveable but not copyable or assignable.
     /// The following code sets this situation up based on whether or not we
     /// have C++11 support or not
-#ifdef _WEBSOCKETPP_DELETED_FUNCTIONS_
-    endpoint(const endpoint& src) = delete;
+#ifdef _WEBSOCKETPP_DEFAULT_DELETE_FUNCTIONS_
+    endpoint(const endpoint & src) = delete;
     endpoint& operator= (const endpoint & rhs) = delete;
 #else
 private:
-    endpoint(const endpoint& src);
-    endpoint& operator= (const endpoint & rhs);
+    endpoint(const endpoint & src);
+    endpoint & operator= (const endpoint & rhs);
 public:
-#endif
+#endif // _WEBSOCKETPP_DEFAULT_DELETE_FUNCTIONS_
 
-#ifdef _WEBSOCKETPP_RVALUE_REFERENCES_
-    endpoint (endpoint&& src)
-      : m_io_service(src.m_io_service)
-      , m_external_io_service(src.m_external_io_service)
+#ifdef _WEBSOCKETPP_MOVE_SEMANTICS_
+    endpoint (endpoint && src)
+      : config::socket_type(std::move(src))
+      , m_tcp_pre_init_handler(src.m_tcp_pre_init_handler)
+      , m_tcp_post_init_handler(src.m_tcp_post_init_handler)
+      , m_io_context(src.m_io_context)
+      , m_external_io_context(src.m_external_io_context)
       , m_acceptor(src.m_acceptor)
-      , m_listen_backlog(boost::asio::socket_base::max_connections)
+      , m_listen_backlog(lib::asio::socket_base::max_listen_connections)
       , m_reuse_addr(src.m_reuse_addr)
+      , m_elog(src.m_elog)
+      , m_alog(src.m_alog)
       , m_state(src.m_state)
     {
-        src.m_io_service = NULL;
-        src.m_external_io_service = false;
+        src.m_io_context = NULL;
+        src.m_external_io_context = false;
         src.m_acceptor = NULL;
         src.m_state = UNINITIALIZED;
     }
 
-    endpoint& operator= (const endpoint && rhs) {
+    /*endpoint & operator= (const endpoint && rhs) {
         if (this != &rhs) {
-            m_io_service = rhs.m_io_service;
-            m_external_io_service = rhs.m_external_io_service;
+            m_io_context = rhs.m_io_context;
+            m_external_io_context = rhs.m_external_io_context;
             m_acceptor = rhs.m_acceptor;
             m_listen_backlog = rhs.m_listen_backlog;
             m_reuse_addr = rhs.m_reuse_addr;
             m_state = rhs.m_state;
 
-            rhs.m_io_service = NULL;
-            rhs.m_external_io_service = false;
+            rhs.m_io_context = NULL;
+            rhs.m_external_io_context = false;
             rhs.m_acceptor = NULL;
-            rhs.m_listen_backlog = boost::asio::socket_base::max_connections;
+            rhs.m_listen_backlog = lib::asio::socket_base::max_listen_connections;
             rhs.m_state = UNINITIALIZED;
+            
+            // TODO: this needs to be updated
         }
         return *this;
-    }
-#endif
+    }*/
+#endif // _WEBSOCKETPP_MOVE_SEMANTICS_
+
     /// Return whether or not the endpoint produces secure connections.
     bool is_secure() const {
         return socket_type::is_secure();
     }
 
-    /// initialize asio transport with external io_service (exception free)
+    /// initialize asio transport with external io_context (exception free)
     /**
      * Initialize the ASIO transport policy for this endpoint using the provided
-     * io_service object. asio_init must be called exactly once on any endpoint
+     * io_context object. asio_init must be called exactly once on any endpoint
      * that uses transport::asio before it can be used.
      *
      * @param ptr A pointer to the io_context to use for asio events
      * @param ec Set to indicate what error occurred, if any.
      */
-    void init_asio(io_service_ptr ptr, lib::error_code & ec) {
+    void init_asio(io_context_ptr ptr, lib::error_code & ec) {
         if (m_state != UNINITIALIZED) {
             m_elog->write(log::elevel::library,
                 "asio::init_asio called from the wrong state");
@@ -181,9 +193,9 @@ class endpoint : public config::socket_type { (public)
 
         m_alog->write(log::alevel::devel,"asio::init_asio");
 
-        m_io_service = ptr;
-        m_external_io_service = true;
-        m_acceptor = lib::make_shared<boost::asio::ip::tcp::acceptor>(*m_io_service);
+        m_io_context = ptr;
+        m_external_io_context = true;
+        m_acceptor.reset(new lib::asio::ip::tcp::acceptor(*m_io_context));
 
         m_state = READY;
         ec = lib::error_code();
@@ -197,7 +209,7 @@ class endpoint : public config::socket_type { (public)
      *
      * @param ptr A pointer to the io_context to use for asio events
      */
-    void init_asio(io_service_ptr ptr) {
+    void init_asio(io_context_ptr ptr) {
         lib::error_code ec;
         init_asio(ptr,ec);
         if (ec) { throw exception(ec); }
@@ -208,13 +220,23 @@ class endpoint : public config::socket_type { (public)
      * This method of initialization will allocate and use an internally managed
      * io_context.
      *
-     * @see init_asio(io_service_ptr ptr)
+     * @see init_asio(io_context_ptr ptr)
      *
      * @param ec Set to indicate what error occurred, if any.
      */
     void init_asio(lib::error_code & ec) {
-        init_asio(new boost::asio::io_context(), ec);
-        m_external_io_service = false;
+        // Use a smart pointer until the call is successful and ownership has 
+        // successfully been taken. Use unique_ptr when available.
+        // TODO: remove the use of auto_ptr when C++98/03 support is no longer
+        //       necessary.
+#ifdef _WEBSOCKETPP_CPP11_MEMORY_
+        lib::unique_ptr<lib::asio::io_context> context(new lib::asio::io_context());
+#else
+        lib::auto_ptr<lib::asio::io_context> context(new lib::asio::io_context());
+#endif
+        init_asio(context.get(), ec);
+        if( !ec ) context.release(); // Call was successful, transfer ownership
+        m_external_io_context = false;
     }
 
     /// Initialize asio transport with internal io_context
@@ -222,13 +244,37 @@ class endpoint : public config::socket_type { (public)
      * This method of initialization will allocate and use an internally managed
      * io_context.
      *
-     * @see init_asio(io_service_ptr ptr)
+     * @see init_asio(io_context_ptr ptr)
      */
     void init_asio() {
-        init_asio(new boost::asio::io_context());
-        m_external_io_service = false;
+        // Use a smart pointer until the call is successful and ownership has 
+        // successfully been taken. Use unique_ptr when available.
+        // TODO: remove the use of auto_ptr when C++98/03 support is no longer
+        //       necessary.
+#ifdef _WEBSOCKETPP_CPP11_MEMORY_
+        lib::unique_ptr<lib::asio::io_context> context(new lib::asio::io_context());
+#else
+        lib::auto_ptr<lib::asio::io_context> context(new lib::asio::io_context());
+#endif
+        init_asio( context.get() );
+        // If control got this far without an exception, then ownership has successfully been taken
+        context.release();
+        m_external_io_context = false;
     }
 
+    /// Sets the tcp pre bind handler
+    /**
+     * The tcp pre bind handler is called after the listen acceptor has
+     * been created but before the socket bind is performed.
+     *
+     * @since 0.8.0
+     *
+     * @param h The handler to call on tcp pre bind init.
+     */
+    void set_tcp_pre_bind_handler(tcp_pre_bind_handler h) {
+        m_tcp_pre_bind_handler = h;
+    }
+
     /// Sets the tcp pre init handler
     /**
      * The tcp pre init handler is called after the raw tcp connection has been
@@ -284,8 +330,10 @@ class endpoint : public config::socket_type { (public)
      *
      * New values affect future calls to listen only.
      *
-     * A value of zero will use the operating system default. This is the
-     * default value.
+     * The default value is specified as *::asio::socket_base::max_listen_connections
+     * which uses the operating system defined maximum queue length. Your OS
+     * may restrict or silently lower this value. A value of zero may cause
+     * all connections to be rejected.
      *
      * @since 0.3.0
      *
@@ -298,11 +346,14 @@ class endpoint : public config::socket_type { (public)
     /// Sets whether to use the SO_REUSEADDR flag when opening listening sockets
     /**
      * Specifies whether or not to use the SO_REUSEADDR TCP socket option. What
-     * this flag does depends on your operating system. Please consult operating
-     * system documentation for more details.
+     * this flag does depends on your operating system.
      *
-     * New values affect future calls to listen only.
+     * Please consult operating system documentation for more details. There
+     * may be security consequences to enabling this option.
      *
+     * New values affect future calls to listen only so set this value prior to
+     * calling listen.
+     *
      * The default is false.
      *
      * @since 0.3.0
@@ -324,9 +375,31 @@ class endpoint : public config::socket_type { (public)
      *
      * @return A reference to the endpoint's io_context
      */
-    boost::asio::io_context & get_io_service() {
-        return *m_io_service;
+    lib::asio::io_context & get_io_context() {
+        return *m_io_context;
     }
+    
+    /// Get local TCP endpoint
+    /**
+     * Extracts the local endpoint from the acceptor. This represents the
+     * address that WebSocket++ is listening on.
+     *
+     * Sets a bad_descriptor error if the acceptor is not currently listening
+     * or otherwise unavailable.
+     * 
+     * @since 0.7.0
+     *
+     * @param ec Set to indicate what error occurred, if any.
+     * @return The local endpoint
+     */
+    lib::asio::ip::tcp::endpoint get_local_endpoint(lib::asio::error_code & ec) {
+        if (m_acceptor) {
+            return m_acceptor->local_endpoint(ec);
+        } else {
+            ec = lib::asio::error::make_error_code(lib::asio::error::bad_descriptor);
+            return lib::asio::ip::tcp::endpoint();
+        }
+    }
 
     /// Set up endpoint for listening manually (exception free)
     /**
@@ -336,7 +409,7 @@ class endpoint : public config::socket_type { (public)
      * @param ep An endpoint to read settings from
      * @param ec Set to indicate what error occurred, if any.
      */
-    void listen(boost::asio::ip::tcp::endpoint const & ep, lib::error_code & ec)
+    void listen(lib::asio::ip::tcp::endpoint const & ep, lib::error_code & ec)
     {
         if (m_state != READY) {
             m_elog->write(log::elevel::library,
@@ -348,37 +421,43 @@ class endpoint : public config::socket_type { (public)
 
         m_alog->write(log::alevel::devel,"asio::listen");
 
-        boost::system::error_code bec;
+        lib::asio::error_code bec;
 
         m_acceptor->open(ep.protocol(),bec);
-        if (!bec) {
-            m_acceptor->set_option(boost::asio::socket_base::reuse_address(m_reuse_addr),bec);
-        }
-        if (!bec) {
-            m_acceptor->bind(ep,bec);
-        }
-        if (!bec) {
-            m_acceptor->listen(m_listen_backlog,bec);
-        }
-        if (bec) {
-            if (m_acceptor->is_open()) {
-                m_acceptor->close();
+        if (bec) {ec = clean_up_listen_after_error(bec);return;}
+        
+        m_acceptor->set_option(lib::asio::socket_base::reuse_address(m_reuse_addr),bec);
+        if (bec) {ec = clean_up_listen_after_error(bec);return;}
+        
+        // if a TCP pre-bind handler is present, run it
+        if (m_tcp_pre_bind_handler) {
+            ec = m_tcp_pre_bind_handler(m_acceptor);
+            if (ec) {
+                ec = clean_up_listen_after_error(ec);
+                return;
             }
-            log_err(log::elevel::info,"asio listen",bec);
-            ec = make_error_code(error::pass_through);
-        } else {
-            m_state = LISTENING;
-            ec = lib::error_code();
         }
+        
+        m_acceptor->bind(ep,bec);
+        if (bec) {ec = clean_up_listen_after_error(bec);return;}
+        
+        m_acceptor->listen(m_listen_backlog,bec);
+        if (bec) {ec = clean_up_listen_after_error(bec);return;}
+        
+        // Success
+        m_state = LISTENING;
+        ec = lib::error_code();
     }
 
+
+
     /// Set up endpoint for listening manually
     /**
      * Bind the internal acceptor using the settings specified by the endpoint e
      *
      * @param ep An endpoint to read settings from
      */
-    void listen(boost::asio::ip::tcp::endpoint const & ep) {
+    void listen(lib::asio::ip::tcp::endpoint const & ep) {
         lib::error_code ec;
         listen(ep,ec);
         if (ec) { throw exception(ec); }
@@ -391,8 +470,8 @@ class endpoint : public config::socket_type { (public)
      * listening.
      *
      * Common options include:
-     * - IPv6 with mapped IPv4 for dual stack hosts boost::asio::ip::tcp::v6()
-     * - IPv4 only: boost::asio::ip::tcp::v4()
+     * - IPv6 with mapped IPv4 for dual stack hosts lib::asio::ip::tcp::v6()
+     * - IPv4 only: lib::asio::ip::tcp::v4()
      *
      * @param internet_protocol The internet protocol to use.
      * @param port The port to listen on.
@@ -402,7 +481,7 @@ class endpoint : public config::socket_type { (public)
     void listen(InternetProtocol const & internet_protocol, uint16_t port,
         lib::error_code & ec)
     {
-        boost::asio::ip::tcp::endpoint ep(internet_protocol, port);
+        lib::asio::ip::tcp::endpoint ep(internet_protocol, port);
         listen(ep,ec);
     }
 
@@ -413,8 +492,8 @@ class endpoint : public config::socket_type { (public)
      * listening.
      *
      * Common options include:
-     * - IPv6 with mapped IPv4 for dual stack hosts boost::asio::ip::tcp::v6()
-     * - IPv4 only: boost::asio::ip::tcp::v4()
+     * - IPv6 with mapped IPv4 for dual stack hosts lib::asio::ip::tcp::v6()
+     * - IPv4 only: lib::asio::ip::tcp::v4()
      *
      * @param internet_protocol The internet protocol to use.
      * @param port The port to listen on.
@@ -422,7 +501,7 @@ class endpoint : public config::socket_type { (public)
     template <typename InternetProtocol>
     void listen(InternetProtocol const & internet_protocol, uint16_t port)
     {
-        boost::asio::ip::tcp::endpoint ep(internet_protocol, port);
+        lib::asio::ip::tcp::endpoint ep(internet_protocol, port);
         listen(ep);
     }
 
@@ -439,7 +518,7 @@ class endpoint : public config::socket_type { (public)
      * @param ec Set to indicate what error occurred, if any.
      */
     void listen(uint16_t port, lib::error_code & ec) {
-        listen(boost::asio::ip::tcp::v6(), port, ec);
+        listen(lib::asio::ip::tcp::v6(), port, ec);
     }
 
     /// Set up endpoint for listening on a port
@@ -455,15 +534,14 @@ class endpoint : public config::socket_type { (public)
      * @param ec Set to indicate what error occurred, if any.
      */
     void listen(uint16_t port) {
-        listen(boost::asio::ip::tcp::v6(), port);
+        listen(lib::asio::ip::tcp::v6(), port);
     }
 
     /// Set up endpoint for listening on a host and service (exception free)
     /**
      * Bind the internal acceptor using the given host and service. More details
-     * about what host and service can be are available in the boost asio
-     * documentation for ip::basic_resolver_query::basic_resolver_query's
-     * constructors.
+     * about what host and service can be are available in the Asio
+     * documentation for the ip::basic_resolver::resolve function.
      *
      * The endpoint must have been initialized by calling init_asio before
      * listening.
@@ -477,23 +555,22 @@ class endpoint : public config::socket_type { (public)
     void listen(std::string const & host, std::string const & service,
         lib::error_code & ec)
     {
-        using boost::asio::ip::tcp;
-        tcp::resolver r(*m_io_service);
-        tcp::resolver::results_type endpoint_iterator = r.resolve(host, service);
-        tcp::resolver::results_type end;
-        if (endpoint_iterator == end) {
+        using lib::asio::ip::tcp;
+        tcp::resolver r(*m_io_context);
+        tcp::resolver::results_type results = r.resolve(host, service);
+        if (results.empty()) {
             m_elog->write(log::elevel::library,
                 "asio::listen could not resolve the supplied host or service");
             ec = make_error_code(error::invalid_host_service);
             return;
         }
-        listen(*endpoint_iterator,ec);
+        listen(*(results.begin()),ec);
     }
 
     /// Set up endpoint for listening on a host and service
     /**
      * Bind the internal acceptor using the given host and service. More details
-     * about what host and service can be are available in the boost asio
+     * about what host and service can be are available in the Asio
      * documentation for ip::basic_resolver_query::basic_resolver_query's
      * constructors.
      *
@@ -558,7 +635,7 @@ class endpoint : public config::socket_type { (public)
 
     /// wraps the run method of the internal io_context object
     std::size_t run() {
-        return m_io_service->run();
+        return m_io_context->run();
     }
 
     /// wraps the run_one method of the internal io_context object
@@ -566,32 +643,32 @@ class endpoint : public config::socket_type { (public)
      * @since 0.3.0-alpha4
      */
     std::size_t run_one() {
-        return m_io_service->run_one();
+        return m_io_context->run_one();
     }
 
     /// wraps the stop method of the internal io_context object
     void stop() {
-        m_io_service->stop();
+        m_io_context->stop();
     }
 
     /// wraps the poll method of the internal io_context object
     std::size_t poll() {
-        return m_io_service->poll();
+        return m_io_context->poll();
     }
 
     /// wraps the poll_one method of the internal io_context object
     std::size_t poll_one() {
-        return m_io_service->poll_one();
+        return m_io_context->poll_one();
     }
 
-    /// wraps the reset method of the internal io_context object
+    /// wraps the restart method of the internal io_context object
     void reset() {
-        m_io_service->restart();
+        m_io_context->restart();
     }
 
     /// wraps the stopped method of the internal io_context object
     bool stopped() const {
-        return m_io_service->stopped();
+        return m_io_context->stopped();
     }
 
     /// Marks the endpoint as perpetual, stopping it from exiting when empty
@@ -607,7 +684,7 @@ class endpoint : public config::socket_type { (public)
      * @since 0.3.0
      */
     void start_perpetual() {
-        m_work = lib::make_shared<boost::asio::executor_work_guard<boost::asio::io_context::executor_type>>(m_io_service->get_executor());
+        m_work_guard.reset(new lib::asio::executor_work_guard<lib::asio::io_context::executor_type>(m_io_context->get_executor()));
     }
 
     /// Clears the endpoint's perpetual flag, allowing it to exit when empty
@@ -619,7 +696,7 @@ class endpoint : public config::socket_type { (public)
      * @since 0.3.0
      */
     void stop_perpetual() {
-        m_work.reset();
+        m_work_guard.reset();
     }
 
     /// Call back a function after a period of time.
@@ -635,9 +712,9 @@ class endpoint : public config::socket_type { (public)
      * needed.
      */
     timer_ptr set_timer(long duration, timer_handler callback) {
-        timer_ptr new_timer = lib::make_shared<boost::asio::deadline_timer>(
-            *m_io_service,
-            boost::posix_time::milliseconds(duration)
+        timer_ptr new_timer = lib::make_shared<lib::asio::steady_timer>(
+            *m_io_context,
+             lib::asio::milliseconds(duration)
         );
 
         new_timer->async_wait(
@@ -663,16 +740,16 @@ class endpoint : public config::socket_type { (public)
      * @param ec A status code indicating an error, if any.
      */
     void handle_timer(timer_ptr, timer_handler callback,
-        boost::system::error_code const & ec)
+        lib::asio::error_code const & ec)
     {
         if (ec) {
-            if (ec == boost::asio::error::operation_aborted) {
+            if (ec == lib::asio::error::operation_aborted) {
                 callback(make_error_code(transport::error::operation_aborted));
             } else {
                 m_elog->write(log::elevel::info,
                     "asio handle_timer error: "+ec.message());
                 log_err(log::elevel::info,"asio handle_timer",ec);
-                callback(make_error_code(error::pass_through));
+                callback(socket_con_type::translate_ec(ec));
             }
         } else {
             callback(lib::error_code());
@@ -688,7 +765,7 @@ class endpoint : public config::socket_type { (public)
     void async_accept(transport_con_ptr tcon, accept_handler callback,
         lib::error_code & ec)
     {
-        if (m_state != LISTENING) {
+        if (m_state != LISTENING || !m_acceptor) {
             using websocketpp::error::make_error_code;
             ec = make_error_code(websocketpp::error::async_accept_not_listening);
             return;
@@ -699,7 +776,7 @@ class endpoint : public config::socket_type { (public)
         if (config::enable_multithreading) {
             m_acceptor->async_accept(
                 tcon->get_raw_socket(),
-                tcon->get_strand()->wrap(lib::bind(
+                lib::asio::bind_executor(*tcon->get_strand(), lib::bind(
                     &type::handle_accept,
                     this,
                     callback,
@@ -740,24 +817,24 @@ class endpoint : public config::socket_type { (public)
      * haven't been constructed yet, and cannot be used in the transport
      * destructor as they will have been destroyed by then.
      */
-    void init_logging(alog_type* a, elog_type* e) {
+    void init_logging(const lib::shared_ptr<alog_type>& a, const lib::shared_ptr<elog_type>& e) {
         m_alog = a;
         m_elog = e;
     }
 
-    void handle_accept(accept_handler callback, boost::system::error_code const
-        & boost_ec)
+    void handle_accept(accept_handler callback, lib::asio::error_code const & 
+        asio_ec)
     {
         lib::error_code ret_ec;
 
         m_alog->write(log::alevel::devel, "asio::handle_accept");
 
-        if (boost_ec) {
-            if (boost_ec == boost::system::errc::operation_canceled) {
+        if (asio_ec) {
+            if (asio_ec == lib::asio::errc::operation_canceled) {
                 ret_ec = make_error_code(websocketpp::error::operation_canceled);
             } else {
-                log_err(log::elevel::info,"asio handle_accept",boost_ec);
-                ret_ec = make_error_code(error::pass_through);
+                log_err(log::elevel::info,"asio handle_accept",asio_ec);
+                ret_ec = socket_con_type::translate_ec(asio_ec);
             }
         }
 
@@ -767,13 +844,15 @@ class endpoint : public config::socket_type { (public)
     /// Initiate a new connection
     // TODO: there have to be some more failure conditions here
     void async_connect(transport_con_ptr tcon, uri_ptr u, connect_handler cb) {
-        using namespace boost::asio::ip;
+        using namespace lib::asio::ip;
 
         // Create a resolver
         if (!m_resolver) {
-            m_resolver = lib::make_shared<boost::asio::ip::tcp::resolver>(*m_io_service);
+            m_resolver.reset(new lib::asio::ip::tcp::resolver(*m_io_context));
         }
 
+        tcon->set_uri(u);
+
         std::string proxy = tcon->get_proxy();
         std::string host;
         std::string port;
@@ -823,7 +902,7 @@ class endpoint : public config::socket_type { (public)
             m_resolver->async_resolve(
                 host,
                 port,
-                tcon->get_strand()->wrap(lib::bind(
+                lib::asio::bind_executor(*tcon->get_strand(), lib::bind(
                     &type::handle_resolve,
                     this,
                     tcon,
@@ -883,11 +962,11 @@ class endpoint : public config::socket_type { (public)
     }
 
     void handle_resolve(transport_con_ptr tcon, timer_ptr dns_timer,
-        connect_handler callback, boost::system::error_code const & ec,
-        boost::asio::ip::tcp::resolver::results_type iterator)
+        connect_handler callback, lib::asio::error_code const & ec,
+        lib::asio::ip::tcp::resolver::results_type results)
     {
-        if (ec == boost::asio::error::operation_aborted ||
-            dns_timer->expires_from_now().is_negative())
+        if (ec == lib::asio::error::operation_aborted ||
+            lib::asio::is_neg(dns_timer->expiry() - timer_ptr::element_type::clock_type::now()))
         {
             m_alog->write(log::alevel::devel,"async_resolve cancelled");
             return;
@@ -897,7 +976,7 @@ class endpoint : public config::socket_type { (public)
 
         if (ec) {
             log_err(log::elevel::info,"asio async_resolve",ec);
-            callback(make_error_code(error::pass_through));
+            callback(socket_con_type::translate_ec(ec));
             return;
         }
 
@@ -905,8 +984,8 @@ class endpoint : public config::socket_type { (public)
             std::stringstream s;
             s << "Async DNS resolve successful. Results: ";
 
-            boost::asio::ip::tcp::resolver::results_type it, end;
-            for (it = iterator; it != end; ++it) {
+            lib::asio::ip::tcp::resolver::results_type::iterator it;
+            for (it = results.begin(); it != results.end(); ++it) {
                 s << (*it).endpoint() << " ";
             }
 
@@ -930,10 +1009,10 @@ class endpoint : public config::socket_type { (public)
         );
 
         if (config::enable_multithreading) {
-            boost::asio::async_connect(
+            lib::asio::async_connect(
                 tcon->get_raw_socket(),
-                iterator,
-                tcon->get_strand()->wrap(lib::bind(
+                results,
+                lib::asio::bind_executor(*tcon->get_strand(), lib::bind(
                     &type::handle_connect,
                     this,
                     tcon,
@@ -943,9 +1022,9 @@ class endpoint : public config::socket_type { (public)
                 ))
             );
         } else {
-            boost::asio::async_connect(
+            lib::asio::async_connect(
                 tcon->get_raw_socket(),
-                iterator,
+                results,
                 lib::bind(
                     &type::handle_connect,
                     this,
@@ -987,15 +1066,15 @@ class endpoint : public config::socket_type { (public)
         }
 
         m_alog->write(log::alevel::devel,"TCP connect timed out");
-        tcon->cancel_socket();
+        tcon->cancel_socket_checked();
         callback(ret_ec);
     }
 
     void handle_connect(transport_con_ptr tcon, timer_ptr con_timer,
-        connect_handler callback, boost::system::error_code const & ec)
+        connect_handler callback, lib::asio::error_code const & ec)
     {
-        if (ec == boost::asio::error::operation_aborted ||
-            con_timer->expires_from_now().is_negative())
+        if (ec == lib::asio::error::operation_aborted ||
+            lib::asio::is_neg(con_timer->expiry() - timer_ptr::element_type::clock_type::now()))
         {
             m_alog->write(log::alevel::devel,"async_connect cancelled");
             return;
@@ -1005,7 +1084,7 @@ class endpoint : public config::socket_type { (public)
 
         if (ec) {
             log_err(log::elevel::info,"asio async_connect",ec);
-            callback(make_error_code(error::pass_through));
+            callback(socket_con_type::translate_ec(ec));
             return;
         }
 
@@ -1037,7 +1116,7 @@ class endpoint : public config::socket_type { (public)
 
         lib::error_code ec;
 
-        ec = tcon->init_asio(m_io_service);
+        ec = tcon->init_asio(m_io_context);
         if (ec) {return ec;}
 
         tcon->set_tcp_pre_init_handler(m_tcp_pre_init_handler);
@@ -1054,6 +1133,16 @@ class endpoint : public config::socket_type { (public)
         m_elog->write(l,s.str());
     }
 
+    /// Helper for cleaning up in the listen method after an error
+    template <typename error_type>
+    lib::error_code clean_up_listen_after_error(error_type const & ec) {
+        if (m_acceptor->is_open()) {
+            m_acceptor->close();
+        }
+        log_err(log::elevel::info,"asio listen",ec);
+        return socket_con_type::translate_ec(ec);
+    }
+
     enum state {
         UNINITIALIZED = 0,
         READY = 1,
@@ -1061,22 +1150,23 @@ class endpoint : public config::socket_type { (public)
     };
 
     // Handlers
+    tcp_pre_bind_handler    m_tcp_pre_bind_handler;
     tcp_init_handler    m_tcp_pre_init_handler;
     tcp_init_handler    m_tcp_post_init_handler;
 
     // Network Resources
-    io_service_ptr      m_io_service;
-    bool                m_external_io_service;
+    io_context_ptr      m_io_context;
+    bool                m_external_io_context;
     acceptor_ptr        m_acceptor;
     resolver_ptr        m_resolver;
-    work_ptr            m_work;
+    work_guard_ptr      m_work_guard;
 
     // Network constants
     int                 m_listen_backlog;
     bool                m_reuse_addr;
 
-    elog_type* m_elog;
-    alog_type* m_alog;
+    lib::shared_ptr<elog_type> m_elog;
+    lib::shared_ptr<alog_type> m_alog;
 
     // Transport state
     state               m_state;
