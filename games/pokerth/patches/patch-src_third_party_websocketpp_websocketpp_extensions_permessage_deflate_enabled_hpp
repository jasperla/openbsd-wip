Index: src/third_party/websocketpp/websocketpp/extensions/permessage_deflate/enabled.hpp
--- src/third_party/websocketpp/websocketpp/extensions/permessage_deflate/enabled.hpp.orig
+++ src/third_party/websocketpp/websocketpp/extensions/permessage_deflate/enabled.hpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ * Copyright (c) 2015, Peter Thorson. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -32,6 +32,7 @@
 #include <websocketpp/common/cpp11.hpp>
 #include <websocketpp/common/memory.hpp>
 #include <websocketpp/common/platforms.hpp>
+#include <websocketpp/common/stdint.hpp>
 #include <websocketpp/common/system_error.hpp>
 #include <websocketpp/error.hpp>
 
@@ -46,14 +47,18 @@
 namespace websocketpp {
 namespace extensions {
 
-/// Implementation of the draft permessage-deflate WebSocket extension
+/// Implementation of RFC 7692, the permessage-deflate WebSocket extension
 /**
  * ### permessage-deflate interface
  *
- * **is_implemented**\n
- * `bool is_implemented()`\n
- * Returns whether or not the object implements the extension or not
+ * **init**\n
+ * `lib::error_code init(bool is_server)`\n
+ * Performs initialization
  *
+ * **is_implimented**\n
+ * `bool is_implimented()`\n
+ * Returns whether or not the object impliments the extension or not
+ *
  * **is_enabled**\n
  * `bool is_enabled()`\n
  * Returns whether or not the extension was negotiated for the current
@@ -136,7 +141,7 @@ class category : public lib::error_category { (public)
             case zlib_error:
                 return "A zlib function returned an error";
             case uninitialized:
-                return "Object must be initialized before use";
+                return "Deflate extension must be initialized before use";
             default:
                 return "Unknown permessage-compress error";
         }
@@ -144,13 +149,13 @@ class category : public lib::error_category { (public)
 };
 
 /// Get a reference to a static copy of the permessage-deflate error category
-lib::error_category const & get_category() {
+inline lib::error_category const & get_category() {
     static category instance;
     return instance;
 }
 
 /// Create an error code in the permessage-deflate category
-lib::error_code make_error_code(error::value e) {
+inline lib::error_code make_error_code(error::value e) {
     return lib::error_code(static_cast<int>(e), get_category());
 }
 
@@ -170,19 +175,31 @@ namespace websocketpp {
 namespace extensions {
 namespace permessage_deflate {
 
-/// Default value for s2c_max_window_bits as defined by RFC6455
-static uint8_t const default_s2c_max_window_bits = 15;
-/// Minimum value for s2c_max_window_bits as defined by RFC6455
-static uint8_t const min_s2c_max_window_bits = 8;
-/// Maximum value for s2c_max_window_bits as defined by RFC6455
-static uint8_t const max_s2c_max_window_bits = 15;
+/// Default value for server_max_window_bits as defined by RFC 7692
+static uint8_t const default_server_max_window_bits = 15;
+/// Minimum value for server_max_window_bits as defined by RFC 7692
+/**
+ * NOTE: A value of 8 is not actually supported by zlib, the deflate
+ * library that WebSocket++ uses. To preserve backwards compatibility
+ * with RFC 7692 and previous versions of the library a value of 8
+ * is accepted by the library but will always be negotiated as 9.
+ */
+static uint8_t const min_server_max_window_bits = 8;
+/// Maximum value for server_max_window_bits as defined by RFC 7692
+static uint8_t const max_server_max_window_bits = 15;
 
-/// Default value for c2s_max_window_bits as defined by RFC6455
-static uint8_t const default_c2s_max_window_bits = 15;
-/// Minimum value for c2s_max_window_bits as defined by RFC6455
-static uint8_t const min_c2s_max_window_bits = 8;
-/// Maximum value for c2s_max_window_bits as defined by RFC6455
-static uint8_t const max_c2s_max_window_bits = 15;
+/// Default value for client_max_window_bits as defined by RFC 7692
+static uint8_t const default_client_max_window_bits = 15;
+/// Minimum value for client_max_window_bits as defined by RFC 7692
+/**
+ * NOTE: A value of 8 is not actually supported by zlib, the deflate
+ * library that WebSocket++ uses. To preserve backwards compatibility
+ * with RFC 7692 and previous versions of the library a value of 8
+ * is accepted by the library but will always be negotiated as 9.
+ */
+static uint8_t const min_client_max_window_bits = 8;
+/// Maximum value for client_max_window_bits as defined by RFC 7692
+static uint8_t const max_client_max_window_bits = 15;
 
 namespace mode {
 enum value {
@@ -202,14 +219,14 @@ class enabled {
 public:
     enabled()
       : m_enabled(false)
-      , m_s2c_no_context_takeover(false)
-      , m_c2s_no_context_takeover(false)
-      , m_s2c_max_window_bits(15)
-      , m_c2s_max_window_bits(15)
-      , m_s2c_max_window_bits_mode(mode::accept)
-      , m_c2s_max_window_bits_mode(mode::accept)
+      , m_server_no_context_takeover(false)
+      , m_client_no_context_takeover(false)
+      , m_server_max_window_bits(15)
+      , m_client_max_window_bits(15)
+      , m_server_max_window_bits_mode(mode::accept)
+      , m_client_max_window_bits_mode(mode::accept)
       , m_initialized(false)
-      , m_compress_buffer_size(16384)
+      , m_compress_buffer_size(8192)
     {
         m_dstate.zalloc = Z_NULL;
         m_dstate.zfree = Z_NULL;
@@ -244,20 +261,25 @@ class enabled {
 
     /// Initialize zlib state
     /**
+     * Note: this should be called *after* the negotiation methods. It will use
+     * information from the negotiation to determine how to initialize the zlib
+     * data structures.
      *
      * @todo memory level, strategy, etc are hardcoded
-     * @todo server detection is hardcoded
+     *
+     * @param is_server True to initialize as a server, false for a client.
+     * @return A code representing the error that occurred, if any
      */
-    lib::error_code init() {
+    lib::error_code init(bool is_server) {
         uint8_t deflate_bits;
         uint8_t inflate_bits;
 
-        if (true /*is_server*/) {
-            deflate_bits = m_s2c_max_window_bits;
-            inflate_bits = m_c2s_max_window_bits;
+        if (is_server) {
+            deflate_bits = m_server_max_window_bits;
+            inflate_bits = m_client_max_window_bits;
         } else {
-            deflate_bits = m_c2s_max_window_bits;
-            inflate_bits = m_s2c_max_window_bits;
+            deflate_bits = m_client_max_window_bits;
+            inflate_bits = m_server_max_window_bits;
         }
 
         int ret = deflateInit2(
@@ -265,8 +287,8 @@ class enabled {
             Z_DEFAULT_COMPRESSION,
             Z_DEFLATED,
             -1*deflate_bits,
-            8, // memory level 1-9
-            /*Z_DEFAULT_STRATEGY*/Z_FIXED
+            4, // memory level 1-9
+            Z_DEFAULT_STRATEGY
         );
 
         if (ret != Z_OK) {
@@ -283,6 +305,14 @@ class enabled {
         }
 
         m_compress_buffer.reset(new unsigned char[m_compress_buffer_size]);
+        m_decompress_buffer.reset(new unsigned char[m_compress_buffer_size]);
+        if ((m_server_no_context_takeover && is_server) ||
+            (m_client_no_context_takeover && !is_server))
+        {
+            m_flush = Z_FULL_FLUSH;
+        } else {
+            m_flush = Z_SYNC_FLUSH;
+        }
         m_initialized = true;
         return lib::error_code();
     }
@@ -329,8 +359,8 @@ class enabled {
      * the option will be in use so they can optimize resource usage if they
      * are able.
      */
-    void enable_s2c_no_context_takeover() {
-        m_s2c_no_context_takeover = true;
+    void enable_server_no_context_takeover() {
+        m_server_no_context_takeover = true;
     }
 
     /// Reset client's outgoing LZ77 sliding window for each new message
@@ -348,15 +378,15 @@ class enabled {
      * This option is supported by all compliant clients and servers. Enabling
      * it via either endpoint should be sufficient to ensure it is used.
      */
-    void enable_c2s_no_context_takeover() {
-        m_c2s_no_context_takeover = true;
+    void enable_client_no_context_takeover() {
+        m_client_no_context_takeover = true;
     }
 
     /// Limit server LZ77 sliding window size
     /**
      * The bits setting is the base 2 logarithm of the maximum window size that
      * the server must use to compress outgoing messages. The permitted range
-     * is 8 to 15 inclusive. 8 represents a 256 byte window and 15 a 32KiB
+     * is 9 to 15 inclusive. 9 represents a 512 byte window and 15 a 32KiB
      * window. The default setting is 15.
      *
      * Mode Options:
@@ -370,25 +400,39 @@ class enabled {
      * adjusted by the server. A server may unilaterally set this value without
      * client support.
      *
+     * NOTE: The permessage-deflate spec specifies that a value of 8 is allowed.
+     * Prior to version 0.8.0 a value of 8 was also allowed by this library.
+     * zlib, the deflate compression library that WebSocket++ uses has always
+     * silently adjusted a value of 8 to 9. In recent versions of zlib (1.2.9 
+     * and greater) a value of 8 is now explicitly rejected. WebSocket++ 0.8.0
+     * continues to perform the 8->9 conversion for backwards compatibility
+     * purposes but this should be considered deprecated functionality.
+     *
      * @param bits The size to request for the outgoing window size
      * @param mode The mode to use for negotiating this parameter
      * @return A status code
      */
-    lib::error_code set_s2c_max_window_bits(uint8_t bits, mode::value mode) {
-        if (bits < min_s2c_max_window_bits || bits > max_s2c_max_window_bits) {
+    lib::error_code set_server_max_window_bits(uint8_t bits, mode::value mode) {
+        if (bits < min_server_max_window_bits || bits > max_server_max_window_bits) {
             return error::make_error_code(error::invalid_max_window_bits);
         }
-        m_s2c_max_window_bits = bits;
-        m_s2c_max_window_bits_mode = mode;
 
+        // See note in doc comment above about what is happening here
+        if (bits == 8) {
+            bits = 9;
+        }
+
+        m_server_max_window_bits = bits;
+        m_server_max_window_bits_mode = mode;
+
         return lib::error_code();
     }
 
     /// Limit client LZ77 sliding window size
     /**
      * The bits setting is the base 2 logarithm of the window size that the
-     * client must use to compress outgoing messages. The permitted range is 8
-     * to 15 inclusive. 8 represents a 256 byte window and 15 a 32KiB window.
+     * client must use to compress outgoing messages. The permitted range is 9
+     * to 15 inclusive. 9 represents a 512 byte window and 15 a 32KiB window.
      * The default setting is 15.
      *
      * Mode Options:
@@ -401,17 +445,31 @@ class enabled {
      * outgoing window size unilaterally. A server may only limit the client's
      * window size if the remote client supports that feature.
      *
+     * NOTE: The permessage-deflate spec specifies that a value of 8 is allowed.
+     * Prior to version 0.8.0 a value of 8 was also allowed by this library.
+     * zlib, the deflate compression library that WebSocket++ uses has always
+     * silently adjusted a value of 8 to 9. In recent versions of zlib (1.2.9 
+     * and greater) a value of 8 is now explicitly rejected. WebSocket++ 0.8.0
+     * continues to perform the 8->9 conversion for backwards compatibility
+     * purposes but this should be considered deprecated functionality.
+     *
      * @param bits The size to request for the outgoing window size
      * @param mode The mode to use for negotiating this parameter
      * @return A status code
      */
-    lib::error_code set_c2s_max_window_bits(uint8_t bits, mode::value mode) {
-        if (bits < min_c2s_max_window_bits || bits > max_c2s_max_window_bits) {
+    lib::error_code set_client_max_window_bits(uint8_t bits, mode::value mode) {
+        if (bits < min_client_max_window_bits || bits > max_client_max_window_bits) {
             return error::make_error_code(error::invalid_max_window_bits);
         }
-        m_c2s_max_window_bits = bits;
-        m_c2s_max_window_bits_mode = mode;
 
+        // See note in doc comment above about what is happening here
+        if (bits == 8) {
+            bits = 9;
+        }
+
+        m_client_max_window_bits = bits;
+        m_client_max_window_bits_mode = mode;
+
         return lib::error_code();
     }
 
@@ -423,7 +481,8 @@ class enabled {
      * @return A WebSocket extension offer string for this extension
      */
     std::string generate_offer() const {
-        return "";
+        // TODO: this should be dynamically generated based on user settings
+        return "permessage-deflate; client_no_context_takeover; client_max_window_bits";
     }
 
     /// Validate extension response
@@ -435,7 +494,7 @@ class enabled {
      * @return Validation error or 0 on success
      */
     lib::error_code validate_offer(http::attribute_list const &) {
-        return make_error_code(error::general);
+        return lib::error_code();
     }
 
     /// Negotiate extension
@@ -452,14 +511,14 @@ class enabled {
 
         http::attribute_list::const_iterator it;
         for (it = offer.begin(); it != offer.end(); ++it) {
-            if (it->first == "s2c_no_context_takeover") {
-                negotiate_s2c_no_context_takeover(it->second,ret.first);
-            } else if (it->first == "c2s_no_context_takeover") {
-                negotiate_c2s_no_context_takeover(it->second,ret.first);
-            } else if (it->first == "s2c_max_window_bits") {
-                negotiate_s2c_max_window_bits(it->second,ret.first);
-            } else if (it->first == "c2s_max_window_bits") {
-                negotiate_c2s_max_window_bits(it->second,ret.first);
+            if (it->first == "server_no_context_takeover") {
+                negotiate_server_no_context_takeover(it->second,ret.first);
+            } else if (it->first == "client_no_context_takeover") {
+                negotiate_client_no_context_takeover(it->second,ret.first);
+            } else if (it->first == "server_max_window_bits") {
+                negotiate_server_max_window_bits(it->second,ret.first);
+            } else if (it->first == "client_max_window_bits") {
+                negotiate_client_max_window_bits(it->second,ret.first);
             } else {
                 ret.first = make_error_code(error::invalid_attributes);
             }
@@ -479,6 +538,9 @@ class enabled {
 
     /// Compress bytes
     /**
+     * @todo: avail_in/out is 32 bit, need to fix for cases of >32 bit frames
+     * on 64 bit machines.
+     *
      * @param [in] in String to compress
      * @param [out] out String to append compressed bytes to
      * @return Error or status code
@@ -490,7 +552,13 @@ class enabled {
 
         size_t output;
 
-        m_dstate.avail_out = m_compress_buffer_size;
+        if (in.empty()) {
+            uint8_t buf[6] = {0x02, 0x00, 0x00, 0x00, 0xff, 0xff};
+            out.append((char *)(buf),6);
+            return lib::error_code();
+        }
+
+        m_dstate.avail_in = in.size();
         m_dstate.next_in = (unsigned char *)(const_cast<char *>(in.data()));
 
         do {
@@ -498,7 +566,7 @@ class enabled {
             m_dstate.avail_out = m_compress_buffer_size;
             m_dstate.next_out = m_compress_buffer.get();
 
-            deflate(&m_dstate, Z_SYNC_FLUSH);
+            deflate(&m_dstate, m_flush);
 
             output = m_compress_buffer_size - m_dstate.avail_out;
 
@@ -529,7 +597,7 @@ class enabled {
 
         do {
             m_istate.avail_out = m_compress_buffer_size;
-            m_istate.next_out = m_compress_buffer.get();
+            m_istate.next_out = m_decompress_buffer.get();
 
             ret = inflate(&m_istate, Z_SYNC_FLUSH);
 
@@ -538,7 +606,7 @@ class enabled {
             }
 
             out.append(
-                reinterpret_cast<char *>(m_compress_buffer.get()),
+                reinterpret_cast<char *>(m_decompress_buffer.get()),
                 m_compress_buffer_size - m_istate.avail_out
             );
         } while (m_istate.avail_out == 0);
@@ -553,35 +621,35 @@ class enabled {
     std::string generate_response() {
         std::string ret = "permessage-deflate";
 
-        if (m_s2c_no_context_takeover) {
-            ret += "; s2c_no_context_takeover";
+        if (m_server_no_context_takeover) {
+            ret += "; server_no_context_takeover";
         }
 
-        if (m_c2s_no_context_takeover) {
-            ret += "; c2s_no_context_takeover";
+        if (m_client_no_context_takeover) {
+            ret += "; client_no_context_takeover";
         }
 
-        if (m_s2c_max_window_bits < default_s2c_max_window_bits) {
+        if (m_server_max_window_bits < default_server_max_window_bits) {
             std::stringstream s;
-            s << int(m_s2c_max_window_bits);
-            ret += "; s2c_max_window_bits="+s.str();
+            s << int(m_server_max_window_bits);
+            ret += "; server_max_window_bits="+s.str();
         }
 
-        if (m_c2s_max_window_bits < default_c2s_max_window_bits) {
+        if (m_client_max_window_bits < default_client_max_window_bits) {
             std::stringstream s;
-            s << int(m_c2s_max_window_bits);
-            ret += "; c2s_max_window_bits="+s.str();
+            s << int(m_client_max_window_bits);
+            ret += "; client_max_window_bits="+s.str();
         }
 
         return ret;
     }
 
-    /// Negotiate s2c_no_context_takeover attribute
+    /// Negotiate server_no_context_takeover attribute
     /**
      * @param [in] value The value of the attribute from the offer
      * @param [out] ec A reference to the error code to return errors via
      */
-    void negotiate_s2c_no_context_takeover(std::string const & value,
+    void negotiate_server_no_context_takeover(std::string const & value,
         lib::error_code & ec)
     {
         if (!value.empty()) {
@@ -589,15 +657,15 @@ class enabled {
             return;
         }
 
-        m_s2c_no_context_takeover = true;
+        m_server_no_context_takeover = true;
     }
 
-    /// Negotiate c2s_no_context_takeover attribute
+    /// Negotiate client_no_context_takeover attribute
     /**
      * @param [in] value The value of the attribute from the offer
      * @param [out] ec A reference to the error code to return errors via
      */
-    void negotiate_c2s_no_context_takeover(std::string const & value,
+    void negotiate_client_no_context_takeover(std::string const & value,
         lib::error_code & ec)
     {
         if (!value.empty()) {
@@ -605,115 +673,139 @@ class enabled {
             return;
         }
 
-        m_c2s_no_context_takeover = true;
+        m_client_no_context_takeover = true;
     }
 
-    /// Negotiate s2c_max_window_bits attribute
+    /// Negotiate server_max_window_bits attribute
     /**
-     * When this method starts, m_s2c_max_window_bits will contain the server's
-     * preferred value and m_s2c_max_window_bits_mode will contain the mode the
+     * When this method starts, m_server_max_window_bits will contain the server's
+     * preferred value and m_server_max_window_bits_mode will contain the mode the
      * server wants to use to for negotiation. `value` contains the value the
      * client requested that we use.
      *
      * options:
-     * - decline (refuse to use the attribute)
-     * - accept (use whatever the client says)
-     * - largest (use largest possible value)
+     * - decline (ignore value, offer our default instead)
+     * - accept (use the value requested by the client)
+     * - largest (use largest value acceptable to both)
      * - smallest (use smallest possible value)
      *
+     * NOTE: As a value of 8 is no longer explicitly supported by zlib but might
+     * be requested for negotiation by an older client/server, if the result of
+     * the negotiation would be to send a value of 8, a value of 9 is offered
+     * instead. This ensures that WebSocket++ will only ever negotiate connections
+     * with compression settings explicitly supported by zlib.
+     *
      * @param [in] value The value of the attribute from the offer
      * @param [out] ec A reference to the error code to return errors via
      */
-    void negotiate_s2c_max_window_bits(std::string const & value,
+    void negotiate_server_max_window_bits(std::string const & value,
         lib::error_code & ec)
     {
         uint8_t bits = uint8_t(atoi(value.c_str()));
 
-        if (bits < min_s2c_max_window_bits || bits > max_s2c_max_window_bits) {
+        if (bits < min_server_max_window_bits || bits > max_server_max_window_bits) {
             ec = make_error_code(error::invalid_attribute_value);
-            m_s2c_max_window_bits = default_s2c_max_window_bits;
+            m_server_max_window_bits = default_server_max_window_bits;
             return;
         }
 
-        switch (m_s2c_max_window_bits_mode) {
+        switch (m_server_max_window_bits_mode) {
             case mode::decline:
-                m_s2c_max_window_bits = default_s2c_max_window_bits;
+                m_server_max_window_bits = default_server_max_window_bits;
                 break;
             case mode::accept:
-                m_s2c_max_window_bits = bits;
+                m_server_max_window_bits = bits;
                 break;
             case mode::largest:
-                m_s2c_max_window_bits = (std::min)(bits,m_s2c_max_window_bits);
+                m_server_max_window_bits = std::min(bits,m_server_max_window_bits);
                 break;
             case mode::smallest:
-                m_s2c_max_window_bits = min_s2c_max_window_bits;
+                m_server_max_window_bits = min_server_max_window_bits;
                 break;
             default:
                 ec = make_error_code(error::invalid_mode);
-                m_s2c_max_window_bits = default_s2c_max_window_bits;
+                m_server_max_window_bits = default_server_max_window_bits;
         }
+
+        // See note in doc comment
+        if (m_server_max_window_bits == 8) {
+            m_server_max_window_bits = 9;
+        }
     }
 
-    /// Negotiate c2s_max_window_bits attribute
+    /// Negotiate client_max_window_bits attribute
     /**
-     * When this method starts, m_c2s_max_window_bits and m_c2s_max_window_mode
+     * When this method starts, m_client_max_window_bits and m_c2s_max_window_mode
      * will contain the server's preferred values for window size and
      * negotiation mode.
      *
      * options:
-     * - decline (refuse to use the attribute)
-     * - accept (use whatever the client says)
-     * - largest (use largest possible value)
+     * - decline (ignore value, offer our default instead)
+     * - accept (use the value requested by the client)
+     * - largest (use largest value acceptable to both)
      * - smallest (use smallest possible value)
      *
+     * NOTE: As a value of 8 is no longer explicitly supported by zlib but might
+     * be requested for negotiation by an older client/server, if the result of
+     * the negotiation would be to send a value of 8, a value of 9 is offered
+     * instead. This ensures that WebSocket++ will only ever negotiate connections
+     * with compression settings explicitly supported by zlib.
+     *
      * @param [in] value The value of the attribute from the offer
      * @param [out] ec A reference to the error code to return errors via
      */
-    void negotiate_c2s_max_window_bits(std::string const & value,
+    void negotiate_client_max_window_bits(std::string const & value,
             lib::error_code & ec)
     {
         uint8_t bits = uint8_t(atoi(value.c_str()));
 
         if (value.empty()) {
-            bits = default_c2s_max_window_bits;
-        } else if (bits < min_c2s_max_window_bits ||
-                   bits > max_c2s_max_window_bits)
+            bits = default_client_max_window_bits;
+        } else if (bits < min_client_max_window_bits ||
+                   bits > max_client_max_window_bits)
         {
             ec = make_error_code(error::invalid_attribute_value);
-            m_c2s_max_window_bits = default_c2s_max_window_bits;
+            m_client_max_window_bits = default_client_max_window_bits;
             return;
         }
 
-        switch (m_c2s_max_window_bits_mode) {
+        switch (m_client_max_window_bits_mode) {
             case mode::decline:
-                m_c2s_max_window_bits = default_c2s_max_window_bits;
+                m_client_max_window_bits = default_client_max_window_bits;
                 break;
             case mode::accept:
-                m_c2s_max_window_bits = bits;
+                m_client_max_window_bits = bits;
                 break;
             case mode::largest:
-                m_c2s_max_window_bits = std::min(bits,m_c2s_max_window_bits);
+                m_client_max_window_bits = std::min(bits,m_client_max_window_bits);
                 break;
             case mode::smallest:
-                m_c2s_max_window_bits = min_c2s_max_window_bits;
+                m_client_max_window_bits = min_client_max_window_bits;
                 break;
             default:
                 ec = make_error_code(error::invalid_mode);
-                m_c2s_max_window_bits = default_c2s_max_window_bits;
+                m_client_max_window_bits = default_client_max_window_bits;
         }
+
+        // See note in doc comment
+        if (m_client_max_window_bits == 8) {
+            m_client_max_window_bits = 9;
+        }
     }
 
     bool m_enabled;
-    bool m_s2c_no_context_takeover;
-    bool m_c2s_no_context_takeover;
-    uint8_t m_s2c_max_window_bits;
-    uint8_t m_c2s_max_window_bits;
-    mode::value m_s2c_max_window_bits_mode;
-    mode::value m_c2s_max_window_bits_mode;
+    bool m_server_no_context_takeover;
+    bool m_client_no_context_takeover;
+    uint8_t m_server_max_window_bits;
+    uint8_t m_client_max_window_bits;
+    mode::value m_server_max_window_bits_mode;
+    mode::value m_client_max_window_bits_mode;
 
     bool m_initialized;
+    int m_flush;
     size_t m_compress_buffer_size;
     lib::unique_ptr_uchar_array m_compress_buffer;
+    lib::unique_ptr_uchar_array m_decompress_buffer;
     z_stream m_dstate;
     z_stream m_istate;
 };
