Index: src/third_party/websocketpp/websocketpp/common/functional.hpp
--- src/third_party/websocketpp/websocketpp/common/functional.hpp.orig
+++ src/third_party/websocketpp/websocketpp/common/functional.hpp
@@ -33,8 +33,10 @@
 // If we've determined that we're in full C++11 mode and the user hasn't
 // explicitly disabled the use of C++11 functional header, then prefer it to
 // boost.
-#ifndef _WEBSOCKETPP_CPP11_FUNCTIONAL_
-    #define _WEBSOCKETPP_CPP11_FUNCTIONAL_
+#if defined _WEBSOCKETPP_CPP11_INTERNAL_ && !defined _WEBSOCKETPP_NO_CPP11_FUNCTIONAL_
+    #ifndef _WEBSOCKETPP_CPP11_FUNCTIONAL_
+        #define _WEBSOCKETPP_CPP11_FUNCTIONAL_
+    #endif
 #endif
 
 // If we're on Visual Studio 2010 or higher and haven't explicitly disabled
@@ -50,7 +52,7 @@
 #ifdef _WEBSOCKETPP_CPP11_FUNCTIONAL_
     #include <functional>
 #else
-    #include <boost/bind/bind.hpp>
+    #include <boost/bind.hpp>
     #include <boost/function.hpp>
     #include <boost/ref.hpp>
 #endif
@@ -66,6 +68,13 @@ namespace lib {
     using std::ref;
     namespace placeholders = std::placeholders;
 
+    // There are some cases where a C++11 compiler balks at using std::ref
+    // but a C++03 compiler using boost function requires boost::ref. As such
+    // lib::ref is not useful in these cases. Instead this macro allows the use
+    // of boost::ref in the case of a boost compile or no reference wrapper at
+    // all in the case of a C++11 compile
+    #define _WEBSOCKETPP_REF(x) x
+
     template <typename T>
     void clear_function(T & x) {
         x = nullptr;
@@ -80,6 +89,9 @@ namespace lib {
         using ::_2;
         using ::_3;
     }
+
+    // See above definition for more details on what this is and why it exists
+    #define _WEBSOCKETPP_REF(x) boost::ref(x)
 
     template <typename T>
     void clear_function(T & x) {
