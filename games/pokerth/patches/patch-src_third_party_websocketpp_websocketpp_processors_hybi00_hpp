Index: src/third_party/websocketpp/websocketpp/processors/hybi00.hpp
--- src/third_party/websocketpp/websocketpp/processors/hybi00.hpp.orig
+++ src/third_party/websocketpp/websocketpp/processors/hybi00.hpp
@@ -29,6 +29,8 @@
 #define WEBSOCKETPP_PROCESSOR_HYBI00_HPP
 
 #include <websocketpp/frame.hpp>
+#include <websocketpp/http/constants.hpp>
+
 #include <websocketpp/utf8_validator.hpp>
 #include <websocketpp/common/network.hpp>
 #include <websocketpp/common/md5.hpp>
@@ -85,9 +87,9 @@ class hybi00 : public processor<config> { (public)
         // Host is required by HTTP/1.1
         // Connection is required by is_websocket_handshake
         // Upgrade is required by is_websocket_handshake
-        if (r.get_header("Sec-WebSocket-Key1") == "" ||
-            r.get_header("Sec-WebSocket-Key2") == "" ||
-            r.get_header("Sec-WebSocket-Key3") == "")
+        if (r.get_header("Sec-WebSocket-Key1").empty() ||
+            r.get_header("Sec-WebSocket-Key2").empty() ||
+            r.get_header("Sec-WebSocket-Key3").empty())
         {
             return make_error_code(error::missing_required_header);
         }
@@ -126,18 +128,18 @@ class hybi00 : public processor<config> { (public)
 
         // Echo back client's origin unless our local application set a
         // more restrictive one.
-        if (res.get_header("Sec-WebSocket-Origin") == "") {
+        if (res.get_header("Sec-WebSocket-Origin").empty()) {
             res.append_header("Sec-WebSocket-Origin",req.get_header("Origin"));
         }
 
         // Echo back the client's request host unless our local application
         // set a different one.
-        if (res.get_header("Sec-WebSocket-Location") == "") {
+        if (res.get_header("Sec-WebSocket-Location").empty()) {
             uri_ptr uri = get_uri(req);
             res.append_header("Sec-WebSocket-Location",uri->str());
         }
 
-        if (subprotocol != "") {
+        if (!subprotocol.empty()) {
             res.replace_header("Sec-WebSocket-Protocol",subprotocol);
         }
 
@@ -186,15 +188,29 @@ class hybi00 : public processor<config> { (public)
 
     /// Extracts requested subprotocols from a handshake request
     /**
-     * hybi00 doesn't support subprotocols so there never will be any requested
+     * hybi00 does support subprotocols
+     * https://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-00#section-1.9
      *
      * @param [in] req The request to extract from
      * @param [out] subprotocol_list A reference to a vector of strings to store
      * the results in.
      */
-    lib::error_code extract_subprotocols(request_type const &, 
-        std::vector<std::string> &)
+    lib::error_code extract_subprotocols(request_type const & req,
+        std::vector<std::string> & subprotocol_list)
     {
+        if (!req.get_header("Sec-WebSocket-Protocol").empty()) {
+            http::parameter_list p;
+
+             if (!req.get_header_as_plist("Sec-WebSocket-Protocol",p)) {
+                 http::parameter_list::const_iterator it;
+
+                 for (it = p.begin(); it != p.end(); ++it) {
+                     subprotocol_list.push_back(it->first);
+                 }
+             } else {
+                 return error::make_error_code(error::subprotocol_parse_error);
+             }
+        }
         return lib::error_code();
     }
 
@@ -400,7 +416,7 @@ class hybi00 : public processor<config> { (public)
 private:
     void decode_client_key(std::string const & key, char * result) const {
         unsigned int spaces = 0;
-        std::string digits = "";
+        std::string digits;
         uint32_t num;
 
         // key2
