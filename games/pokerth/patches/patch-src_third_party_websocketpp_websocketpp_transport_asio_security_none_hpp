Index: src/third_party/websocketpp/websocketpp/transport/asio/security/none.hpp
--- src/third_party/websocketpp/websocketpp/transport/asio/security/none.hpp.orig
+++ src/third_party/websocketpp/websocketpp/transport/asio/security/none.hpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ * Copyright (c) 2015, Peter Thorson. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -28,12 +28,14 @@
 #ifndef WEBSOCKETPP_TRANSPORT_SECURITY_NONE_HPP
 #define WEBSOCKETPP_TRANSPORT_SECURITY_NONE_HPP
 
+#include <websocketpp/uri.hpp>
+
+#include <websocketpp/transport/base/connection.hpp>
 #include <websocketpp/transport/asio/security/base.hpp>
 
+#include <websocketpp/common/asio.hpp>
 #include <websocketpp/common/memory.hpp>
 
-#include <boost/asio.hpp>
-
 #include <sstream>
 #include <string>
 
@@ -45,13 +47,13 @@ namespace asio {
 namespace basic_socket {
 
 /// The signature of the socket init handler for this socket policy
-typedef lib::function<void(connection_hdl,boost::asio::ip::tcp::socket&)>
+typedef lib::function<void(connection_hdl,lib::asio::ip::tcp::socket&)>
     socket_init_handler;
 
-/// Basic Boost ASIO connection socket component
+/// Basic Asio connection socket component
 /**
  * transport::asio::basic_socket::connection implements a connection socket
- * component using Boost ASIO ip::tcp::socket.
+ * component using Asio ip::tcp::socket.
  */
 class connection : public lib::enable_shared_from_this<connection> {
 public:
@@ -60,12 +62,12 @@ class connection : public lib::enable_shared_from_this
     /// Type of a shared pointer to this connection socket component
     typedef lib::shared_ptr<type> ptr;
 
-    /// Type of a pointer to the ASIO io_context being used
-    typedef boost::asio::io_context* io_service_ptr;
-    /// Type of a pointer to the ASIO io_context strand being used
-    typedef lib::shared_ptr<boost::asio::io_context::strand> strand_ptr;
+    /// Type of a pointer to the Asio io_context being used
+    typedef lib::asio::io_context* io_context_ptr;
+    /// Type of a pointer to the Asio io_context strand being used
+    typedef lib::shared_ptr<lib::asio::io_context::strand> strand_ptr;
     /// Type of the ASIO socket being used
-    typedef boost::asio::ip::tcp::socket socket_type;
+    typedef lib::asio::ip::tcp::socket socket_type;
     /// Type of a shared pointer to the socket being used.
     typedef lib::shared_ptr<socket_type> socket_ptr;
 
@@ -91,7 +93,7 @@ class connection : public lib::enable_shared_from_this
     /**
      * The socket initialization handler is called after the socket object is
      * created but before it is used. This gives the application a chance to
-     * set any ASIO socket options it needs.
+     * set any Asio socket options it needs.
      *
      * @param h The new socket_init_handler
      */
@@ -103,7 +105,7 @@ class connection : public lib::enable_shared_from_this
     /**
      * This is used internally. It can also be used to set socket options, etc
      */
-    boost::asio::ip::tcp::socket& get_socket() {
+    lib::asio::ip::tcp::socket & get_socket() {
         return *m_socket;
     }
 
@@ -111,7 +113,7 @@ class connection : public lib::enable_shared_from_this
     /**
      * This is used internally.
      */
-    boost::asio::ip::tcp::socket& get_next_layer() {
+    lib::asio::ip::tcp::socket & get_next_layer() {
         return *m_socket;
     }
 
@@ -119,7 +121,7 @@ class connection : public lib::enable_shared_from_this
     /**
      * This is used internally. It can also be used to set socket options, etc
      */
-    boost::asio::ip::tcp::socket& get_raw_socket() {
+    lib::asio::ip::tcp::socket & get_raw_socket() {
         return *m_socket;
     }
 
@@ -133,16 +135,16 @@ class connection : public lib::enable_shared_from_this
      *
      * @return A string identifying the address of the remote endpoint
      */
-    std::string get_remote_endpoint(lib::error_code &ec) const {
+    std::string get_remote_endpoint(lib::error_code & ec) const {
         std::stringstream s;
 
-        boost::system::error_code bec;
-        boost::asio::ip::tcp::endpoint ep = m_socket->remote_endpoint(bec);
+        lib::asio::error_code aec;
+        lib::asio::ip::tcp::endpoint ep = m_socket->remote_endpoint(aec);
 
-        if (bec) {
+        if (aec) {
             ec = error::make_error_code(error::pass_through);
-            s << "Error getting remote endpoint: " << bec
-               << " (" << bec.message() << ")";
+            s << "Error getting remote endpoint: " << aec
+               << " (" << aec.message() << ")";
             return s.str();
         } else {
             ec = lib::error_code();
@@ -154,25 +156,42 @@ class connection : public lib::enable_shared_from_this
     /// Perform one time initializations
     /**
      * init_asio is called once immediately after construction to initialize
-     * boost::asio components to the io_context
+     * Asio components to the io_context
      *
-     * @param service A pointer to the endpoint's io_context
+     * @param context A pointer to the endpoint's io_context
      * @param strand A shared pointer to the connection's asio strand
      * @param is_server Whether or not the endpoint is a server or not.
      */
-    lib::error_code init_asio (io_service_ptr service, strand_ptr, bool)
+    lib::error_code init_asio (io_context_ptr context, strand_ptr, bool)
     {
         if (m_state != UNINITIALIZED) {
             return socket::make_error_code(socket::error::invalid_state);
         }
 
-        m_socket = lib::make_shared<boost::asio::ip::tcp::socket>(*service);
+        m_socket.reset(new lib::asio::ip::tcp::socket(*context));
 
+        if (m_socket_init_handler) {
+            m_socket_init_handler(m_hdl, *m_socket);
+        }
+
         m_state = READY;
 
         return lib::error_code();
     }
 
+    /// Set uri hook
+    /**
+     * Called by the transport as a connection is being established to provide
+     * the uri being connected to to the security/socket layer.
+     *
+     * This socket policy doesn't use the uri so it is ignored.
+     *
+     * @since 0.6.0
+     *
+     * @param u The uri to set
+     */
+    void set_uri(uri_ptr) {}
+
     /// Pre-initialize security policy
     /**
      * Called by the transport after a new connection is created to initialize
@@ -188,10 +207,6 @@ class connection : public lib::enable_shared_from_this
             return;
         }
 
-        if (m_socket_init_handler) {
-            m_socket_init_handler(m_hdl,*m_socket);
-        }
-
         m_state = READING;
 
         callback(lib::error_code());
@@ -221,13 +236,23 @@ class connection : public lib::enable_shared_from_this
     }
 
     /// Cancel all async operations on this socket
-    void cancel_socket() {
-        m_socket->cancel();
+    /**
+     * Attempts to cancel all async operations on this socket and reports any
+     * failures.
+     *
+     * NOTE: Windows XP and earlier do not support socket cancellation.
+     *
+     * @return The error that occurred, if any.
+     */
+    lib::asio::error_code cancel_socket() {
+        lib::asio::error_code ec;
+        m_socket->cancel(ec);
+        return ec;
     }
 
-    void async_shutdown(socket_shutdown_handler h) {
-        boost::system::error_code ec;
-        m_socket->shutdown(boost::asio::ip::tcp::socket::shutdown_both,ec);
+    void async_shutdown(socket::shutdown_handler h) {
+        lib::asio::error_code ec;
+        m_socket->shutdown(lib::asio::ip::tcp::socket::shutdown_both, ec);
         h(ec);
     }
 
@@ -235,21 +260,40 @@ class connection : public lib::enable_shared_from_this
         return lib::error_code();
     }
 
+public:
     /// Translate any security policy specific information about an error code
     /**
-     * Translate_ec takes a boost error code and attempts to convert its value
-     * to an appropriate websocketpp error code. The plain socket policy does
-     * not presently provide any additional information so all errors will be
-     * reported as the generic transport pass_through error.
+     * Translate_ec takes an Asio error code and attempts to convert its value 
+     * to an appropriate websocketpp error code. In the case that the Asio and
+     * Websocketpp error types are the same (such as using boost::asio and
+     * boost::system_error or using standalone asio and std::system_error the
+     * code will be passed through natively.
      *
+     * In the case of a mismatch (boost::asio with std::system_error) a
+     * translated code will be returned. The plain socket policy does not have 
+     * any additional information so all such errors will be reported as the
+     * generic transport pass_through error.
+     *
      * @since 0.3.0
      *
      * @param ec The error code to translate_ec
      * @return The translated error code
      */
-    lib::error_code translate_ec(boost::system::error_code) {
+    template <typename ErrorCodeType>
+    static
+    lib::error_code translate_ec(ErrorCodeType) {
         // We don't know any more information about this error so pass through
         return make_error_code(transport::error::pass_through);
+    }
+
+    static
+    /// Overload of translate_ec to catch cases where lib::error_code is the 
+    /// same type as lib::asio::error_code
+    lib::error_code translate_ec(lib::error_code ec) {
+        // We don't know any more information about this error, but the error is
+        // the same type as the one we are translating to, so pass through
+        // untranslated.
+        return ec;
     }
 private:
     enum state {
