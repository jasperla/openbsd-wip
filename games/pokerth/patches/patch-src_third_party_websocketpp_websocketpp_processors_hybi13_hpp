Index: src/third_party/websocketpp/websocketpp/processors/hybi13.hpp
--- src/third_party/websocketpp/websocketpp/processors/hybi13.hpp.orig
+++ src/third_party/websocketpp/websocketpp/processors/hybi13.hpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ * Copyright (c) 2015, Peter Thorson. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -85,7 +85,21 @@ class hybi13 : public processor<config> { (public)
         return m_permessage_deflate.is_implemented();
     }
 
-    err_str_pair negotiate_extensions(request_type const & req) {
+    err_str_pair negotiate_extensions(request_type const & request) {
+        return negotiate_extensions_helper(request);
+    }
+    
+    err_str_pair negotiate_extensions(response_type const & response) {
+        return negotiate_extensions_helper(response);
+    }
+    
+    /// Extension negotiation helper function
+    /**
+     * This exists mostly because the code for requests and responses is
+     * identical and I can't have virtual template methods.
+     */
+    template <typename header_type>
+    err_str_pair negotiate_extensions_helper(header_type const & header) {
         err_str_pair ret;
 
         // Respect blanket disabling of all extensions and don't even parse
@@ -97,7 +111,7 @@ class hybi13 : public processor<config> { (public)
 
         http::parameter_list p;
 
-        bool error = req.get_header_as_plist("Sec-WebSocket-Extensions",p);
+        bool error = header.get_header_as_plist("Sec-WebSocket-Extensions",p);
 
         if (error) {
             ret.first = make_error_code(error::extension_parse_error);
@@ -111,29 +125,60 @@ class hybi13 : public processor<config> { (public)
 
         http::parameter_list::const_iterator it;
 
+        // look through the list of extension requests to find the first
+        // one that we can accept.
         if (m_permessage_deflate.is_implemented()) {
             err_str_pair neg_ret;
             for (it = p.begin(); it != p.end(); ++it) {
-                // look through each extension, if the key is permessage-deflate
-                if (it->first == "permessage-deflate") {
-                    neg_ret = m_permessage_deflate.negotiate(it->second);
+                // not a permessage-deflate extension request, ignore
+                if (it->first != "permessage-deflate") {
+                    continue;
+                }
 
-                    if (neg_ret.first) {
-                        // Figure out if this is an error that should halt all
-                        // extension negotiations or simply cause negotiation of
-                        // this specific extension to fail.
-                        //std::cout << "permessage-compress negotiation failed: "
-                        //          << neg_ret.first.message() << std::endl;
-                    } else {
-                        // Note: this list will need commas if WebSocket++ ever
-                        // supports more than one extension
-                        ret.second += neg_ret.second;
-                        continue;
-                    }
+                // if we have already successfully negotiated this extension
+                // then skip any other requests to negotiate the same one
+                // with different parameters 
+                if (m_permessage_deflate.is_enabled()) {
+                    continue;
                 }
+                
+                // attempt to negotiate this offer
+                neg_ret = m_permessage_deflate.negotiate(it->second);
+
+                if (neg_ret.first) {
+                    // negotiation offer failed. Do nothing. We will continue
+                    // searching for a permessage-deflate config that succeeds
+                    continue;
+                }
+
+                // Negotiation tentatively succeeded
+
+                // Actually try to initialize the extension before we
+                // deem negotiation complete
+                lib::error_code ec = m_permessage_deflate.init(base::m_server);
+
+                if (ec) {
+                    // Negotiation succeeded but initialization failed this is 
+                    // an error that should stop negotiation of permessage 
+                    // deflate. Return the reason for the init failure
+
+                    ret.first = ec;
+                    break;
+                } else {
+                    // Successfully initialized, push the negotiated response into
+                    // the reply and stop looking for additional permessage-deflate
+                    // extensions
+                    ret.second += neg_ret.second;
+                    break;
+                }
             }
         }
 
+        // support for future extensions would go here. Should check the value of 
+        // ret.first before continuing. Might need to consider whether failure of
+        // negotiation of an earlier extension should stop negotiation of subsequent
+        // ones
+
         return ret;
     }
 
@@ -150,7 +195,7 @@ class hybi13 : public processor<config> { (public)
         // Host is required by HTTP/1.1
         // Connection is required by is_websocket_handshake
         // Upgrade is required by is_websocket_handshake
-        if (r.get_header("Sec-WebSocket-Key") == "") {
+        if (r.get_header("Sec-WebSocket-Key").empty()) {
             return make_error_code(error::missing_required_header);
         }
 
@@ -223,6 +268,13 @@ class hybi13 : public processor<config> { (public)
 
         req.replace_header("Sec-WebSocket-Key",base64_encode(raw_key, 16));
 
+        if (m_permessage_deflate.is_implemented()) {
+            std::string offer = m_permessage_deflate.generate_offer();
+            if (!offer.empty()) {
+                req.replace_header("Sec-WebSocket-Extensions",offer);
+            }
+        }
+
         return lib::error_code();
     }
 
@@ -264,6 +316,8 @@ class hybi13 : public processor<config> { (public)
             return error::make_error_code(error::missing_required_header);
         }
 
+        // check extensions
+
         return lib::error_code();
     }
 
@@ -391,6 +445,10 @@ class hybi13 : public processor<config> { (public)
                             m_msg_manager->get_message(op,m_bytes_needed),
                             frame::get_masking_key(m_basic_header,m_extended_header)
                         );
+                        
+                        if (m_permessage_deflate.is_enabled()) {
+                            m_data_msg.msg_ptr->set_compressed(frame::get_rsv1(m_basic_header));
+                        }
                     } else {
                         // Fetch the underlying payload buffer from the data message we
                         // are writing into.
@@ -432,15 +490,10 @@ class hybi13 : public processor<config> { (public)
                 // If this was the last frame in the message set the ready flag.
                 // Otherwise, reset processor state to read additional frames.
                 if (frame::get_fin(m_basic_header)) {
-                    // ensure that text messages end on a valid UTF8 code point
-                    if (frame::get_opcode(m_basic_header) == frame::opcode::TEXT) {
-                        if (!m_current_msg->validator.complete()) {
-                            ec = make_error_code(error::invalid_utf8);
-                            break;
-                        }
+                    ec = finalize_message();
+                    if (ec) {
+                        break;
                     }
-
-                    m_state = READY;
                 } else {
                     this->reset_headers();
                 }
@@ -454,6 +507,44 @@ class hybi13 : public processor<config> { (public)
         return p;
     }
 
+    /// Perform any finalization actions on an incoming message
+    /**
+     * Called after the full message is received. Provides the opportunity for
+     * extensions to complete any data post processing as well as final UTF8
+     * validation checks for text messages.
+     *
+     * @return A code indicating errors, if any
+     */
+    lib::error_code finalize_message() {
+        std::string & out = m_current_msg->msg_ptr->get_raw_payload();
+
+        // if the frame is compressed, append the compression
+        // trailer and flush the compression buffer.
+        if (m_permessage_deflate.is_enabled()
+            && m_current_msg->msg_ptr->get_compressed())
+        {
+            uint8_t trailer[4] = {0x00, 0x00, 0xff, 0xff};
+
+            // Decompress current buffer into the message buffer
+            lib::error_code ec;
+            ec = m_permessage_deflate.decompress(trailer,4,out);
+            if (ec) {
+                return ec;
+            }
+        }
+
+        // ensure that text messages end on a valid UTF8 code point
+        if (frame::get_opcode(m_basic_header) == frame::opcode::TEXT) {
+            if (!m_current_msg->validator.complete()) {
+                return make_error_code(error::invalid_utf8);
+            }
+        }
+
+        m_state = READY;
+
+        return lib::error_code();
+    }
+
     void reset_headers() {
         m_state = HEADER_BASIC;
         m_bytes_needed = frame::BASIC_HEADER_LENGTH;
@@ -505,19 +596,6 @@ class hybi13 : public processor<config> { (public)
      * Performs validation, masking, compression, etc. will return an error if
      * there was an error, otherwise msg will be ready to be written
      *
-     * By default WebSocket++ performs block masking/unmasking in a manner that
-     * makes assumptions about the nature of the machine and STL library used.
-     * In particular the assumption is either a 32 or 64 bit word size and an
-     * STL with std::string::data returning a contiguous char array.
-     *
-     * This method improves masking performance by 3-8x depending on the ratio
-     * of small to large messages and the availability of a 64 bit processor.
-     *
-     * To disable this optimization (for use with alternative STL
-     * implementations or processors) define WEBSOCKETPP_STRICT_MASKING when
-     * compiling the library. This will force the library to perform masking in
-     * single byte chunks.
-     *
      * TODO: tests
      *
      * @param in An unprepared message to prepare
@@ -551,18 +629,11 @@ class hybi13 : public processor<config> { (public)
                           && in->get_compressed();
         bool fin = in->get_fin();
 
-        // generate header
-        frame::basic_header h(op,i.size(),fin,masked,compressed);
-
         if (masked) {
             // Generate masking key.
             key.i = m_rng();
-
-            frame::extended_header e(i.size(),key.i);
-            out->set_header(frame::prepare_header(h,e));
         } else {
-            frame::extended_header e(i.size());
-            out->set_header(frame::prepare_header(h,e));
+            key.i = 0;
         }
 
         // prepare payload
@@ -570,6 +641,14 @@ class hybi13 : public processor<config> { (public)
             // compress and store in o after header.
             m_permessage_deflate.compress(i,o);
 
+            if (o.size() < 4) {
+                return make_error_code(error::general);
+            }
+
+            // Strip trailing 4 0x00 0x00 0xff 0xff bytes before writing to the
+            // wire
+            o.resize(o.size()-4);
+
             // mask in place if necessary
             if (masked) {
                 this->masked_copy(o,o,key);
@@ -588,6 +667,17 @@ class hybi13 : public processor<config> { (public)
             }
         }
 
+        // generate header
+        frame::basic_header h(op,o.size(),fin,masked,compressed);
+
+        if (masked) {
+            frame::extended_header e(o.size(),key.i);
+            out->set_header(frame::prepare_header(h,e));
+        } else {
+            frame::extended_header e(o.size());
+            out->set_header(frame::prepare_header(h,e));
+        }
+
         out->set_prepared(true);
         out->set_opcode(op);
 
@@ -710,19 +800,9 @@ class hybi13 : public processor<config> { (public)
     {
         // unmask if masked
         if (frame::get_masked(m_basic_header)) {
-            #ifdef WEBSOCKETPP_STRICT_MASKING
-                m_current_msg->prepared_key = frame::byte_mask_circ(
-                    buf,
-                    len,
-                    m_current_msg->prepared_key
-                );
-            #else
-                m_current_msg->prepared_key = frame::word_mask_circ(
-                    buf,
-                    len,
-                    m_current_msg->prepared_key
-                );
-            #endif
+            m_current_msg->prepared_key = frame::byte_mask_circ(
+                buf, len, m_current_msg->prepared_key);
+            // TODO: SIMD masking
         }
 
         std::string & out = m_current_msg->msg_ptr->get_raw_payload();
@@ -730,13 +810,13 @@ class hybi13 : public processor<config> { (public)
 
         // decompress message if needed.
         if (m_permessage_deflate.is_enabled()
-            && frame::get_rsv1(m_basic_header))
+            && m_current_msg->msg_ptr->get_compressed())
         {
             // Decompress current buffer into the message buffer
-            m_permessage_deflate.decompress(buf,len,out);
-
-            // get the length of the newly uncompressed output
-            offset = out.size() - offset;
+            ec = m_permessage_deflate.decompress(buf,len,out);
+            if (ec) {
+                return 0;
+            }
         } else {
             // No compression, straight copy
             out.append(reinterpret_cast<char *>(buf),len);
@@ -881,16 +961,8 @@ class hybi13 : public processor<config> { (public)
     void masked_copy (std::string const & i, std::string & o,
         frame::masking_key_type key) const
     {
-        #ifdef WEBSOCKETPP_STRICT_MASKING
-            frame::byte_mask(i.begin(),i.end(),o.begin(),key);
-        #else
-            websocketpp::frame::word_mask_exact(
-                reinterpret_cast<uint8_t *>(const_cast<char *>(i.data())),
-                reinterpret_cast<uint8_t *>(const_cast<char *>(o.data())),
-                i.size(),
-                key
-            );
-        #endif
+        frame::byte_mask(i.begin(),i.end(),o.begin(),key);
+        // TODO: SIMD masking
     }
 
     /// Generic prepare control frame with opcode and payload.
@@ -937,7 +1009,8 @@ class hybi13 : public processor<config> { (public)
             out->set_header(frame::prepare_header(h,e));
             std::copy(payload.begin(),payload.end(),o.begin());
         }
-
+    
+        out->set_opcode(op);
         out->set_prepared(true);
 
         return lib::error_code();
