Index: src/third_party/websocketpp/websocketpp/roles/server_endpoint.hpp
--- src/third_party/websocketpp/websocketpp/roles/server_endpoint.hpp.orig
+++ src/third_party/websocketpp/websocketpp/roles/server_endpoint.hpp
@@ -64,11 +64,35 @@ class server : public endpoint<connection<config>,conf
     /// Type of the endpoint component of this server
     typedef endpoint<connection_type,config> endpoint_type;
 
+    friend class connection<config>;
+
     explicit server() : endpoint_type(true)
     {
-        endpoint_type::m_alog.write(log::alevel::devel, "server constructor");
+        endpoint_type::m_alog->write(log::alevel::devel, "server constructor");
     }
 
+    /// Destructor
+    ~server<config>() {}
+
+#ifdef _WEBSOCKETPP_DEFAULT_DELETE_FUNCTIONS_
+    // no copy constructor because endpoints are not copyable
+    server<config>(server<config> &) = delete;
+
+    // no copy assignment operator because endpoints are not copyable
+    server<config> & operator=(server<config> const &) = delete;
+#endif // _WEBSOCKETPP_DEFAULT_DELETE_FUNCTIONS_
+
+#ifdef _WEBSOCKETPP_MOVE_SEMANTICS_
+    /// Move constructor
+    server<config>(server<config> && o) : endpoint<connection<config>,config>(std::move(o)) {}
+
+#ifdef _WEBSOCKETPP_DEFAULT_DELETE_FUNCTIONS_
+    // no move assignment operator because of const member variables
+    server<config> & operator=(server<config> &&) = delete;
+#endif // _WEBSOCKETPP_DEFAULT_DELETE_FUNCTIONS_
+
+#endif // _WEBSOCKETPP_MOVE_SEMANTICS_
+
     /// Create and initialize a new connection
     /**
      * The connection will be initialized and ready to begin. Call its start()
@@ -91,7 +115,7 @@ class server : public endpoint<connection<config>,conf
      *
      * Refer to documentation for the transport policy you are using for
      * instructions on how to stop this acceptance loop.
-     * 
+     *
      * @param [out] ec A status code indicating an error, if any.
      */
     void start_accept(lib::error_code & ec) {
@@ -102,13 +126,18 @@ class server : public endpoint<connection<config>,conf
         
         ec = lib::error_code();
         connection_ptr con = get_connection();
-        
+
+        if (!con) {
+          ec = error::make_error_code(error::con_creation_failed);
+          return;
+        }
+
         transport_type::async_accept(
             lib::static_pointer_cast<transport_con_type>(con),
             lib::bind(&type::handle_accept,this,con,lib::placeholders::_1),
             ec
         );
-        
+
         if (ec && con) {
             // If the connection was constructed but the accept failed,
             // terminate the connection to prevent memory leaks
@@ -119,8 +148,8 @@ class server : public endpoint<connection<config>,conf
     /// Starts the server's async connection acceptance loop
     /**
      * Initiates the server connection acceptance loop. Must be called after
-     * listen. This method will have no effect until the underlying io_context
-     * starts running. It may be called after the io_context is already running.
+     * listen. This method will have no effect until the underlying io_service
+     * starts running. It may be called after the io_service is already running.
      *
      * Refer to documentation for the transport policy you are using for
      * instructions on how to stop this acceptance loop.
@@ -139,10 +168,10 @@ class server : public endpoint<connection<config>,conf
             con->terminate(ec);
 
             if (ec == error::operation_canceled) {
-                endpoint_type::m_elog.write(log::elevel::info,
+                endpoint_type::m_elog->write(log::elevel::info,
                     "handle_accept error: "+ec.message());
             } else {
-                endpoint_type::m_elog.write(log::elevel::rerror,
+                endpoint_type::m_elog->write(log::elevel::rerror,
                     "handle_accept error: "+ec.message());
             }
         } else {
@@ -152,10 +181,10 @@ class server : public endpoint<connection<config>,conf
         lib::error_code start_ec;
         start_accept(start_ec);
         if (start_ec == error::async_accept_not_listening) {
-            endpoint_type::m_elog.write(log::elevel::info,
+            endpoint_type::m_elog->write(log::elevel::info,
                 "Stopping acceptance of new connections because the underlying transport is no longer listening.");
         } else if (start_ec) {
-            endpoint_type::m_elog.write(log::elevel::rerror,
+            endpoint_type::m_elog->write(log::elevel::rerror,
                 "Restarting async_accept loop failed: "+ec.message());
         }
     }
