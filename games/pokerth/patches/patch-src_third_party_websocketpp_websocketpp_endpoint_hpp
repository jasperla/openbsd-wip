Index: src/third_party/websocketpp/websocketpp/endpoint.hpp
--- src/third_party/websocketpp/websocketpp/endpoint.hpp.orig
+++ src/third_party/websocketpp/websocketpp/endpoint.hpp
@@ -85,9 +85,12 @@ class endpoint : public config::transport_type, public
     // TODO: organize these
     typedef typename connection_type::termination_handler termination_handler;
 
+    // This would be ideal. Requires C++11 though
+    //friend connection;
+
     explicit endpoint(bool p_is_server)
-      : m_alog(config::alog_level, log::channel_type_hint::access)
-      , m_elog(config::elog_level, log::channel_type_hint::error)
+      : m_alog(new alog_type(config::alog_level, log::channel_type_hint::access))
+      , m_elog(new elog_type(config::elog_level, log::channel_type_hint::error))
       , m_user_agent(::websocketpp::user_agent)
       , m_open_handshake_timeout_dur(config::timeout_open_handshake)
       , m_close_handshake_timeout_dur(config::timeout_close_handshake)
@@ -96,14 +99,64 @@ class endpoint : public config::transport_type, public
       , m_max_http_body_size(config::max_http_body_size)
       , m_is_server(p_is_server)
     {
-        m_alog.set_channels(config::alog_level);
-        m_elog.set_channels(config::elog_level);
+        m_alog->set_channels(config::alog_level);
+        m_elog->set_channels(config::elog_level);
 
-        m_alog.write(log::alevel::devel, "endpoint constructor");
+        m_alog->write(log::alevel::devel, "endpoint constructor");
 
-        transport_type::init_logging(&m_alog, &m_elog);
+        transport_type::init_logging(m_alog, m_elog);
     }
 
+
+    /// Destructor
+    ~endpoint<connection,config>() {}
+
+    #ifdef _WEBSOCKETPP_DEFAULT_DELETE_FUNCTIONS_
+        // no copy constructor because endpoints are not copyable
+        endpoint(endpoint &) = delete;
+    
+        // no copy assignment operator because endpoints are not copyable
+        endpoint & operator=(endpoint const &) = delete;
+    #endif // _WEBSOCKETPP_DEFAULT_DELETE_FUNCTIONS_
+
+    #ifdef _WEBSOCKETPP_MOVE_SEMANTICS_
+        /// Move constructor
+        endpoint(endpoint && o) 
+         : config::transport_type(std::move(o))
+         , config::endpoint_base(std::move(o))
+         , m_alog(std::move(o.m_alog))
+         , m_elog(std::move(o.m_elog))
+         , m_user_agent(std::move(o.m_user_agent))
+         , m_open_handler(std::move(o.m_open_handler))
+         
+         , m_close_handler(std::move(o.m_close_handler))
+         , m_fail_handler(std::move(o.m_fail_handler))
+         , m_ping_handler(std::move(o.m_ping_handler))
+         , m_pong_handler(std::move(o.m_pong_handler))
+         , m_pong_timeout_handler(std::move(o.m_pong_timeout_handler))
+         , m_interrupt_handler(std::move(o.m_interrupt_handler))
+         , m_http_handler(std::move(o.m_http_handler))
+         , m_validate_handler(std::move(o.m_validate_handler))
+         , m_message_handler(std::move(o.m_message_handler))
+
+         , m_open_handshake_timeout_dur(o.m_open_handshake_timeout_dur)
+         , m_close_handshake_timeout_dur(o.m_close_handshake_timeout_dur)
+         , m_pong_timeout_dur(o.m_pong_timeout_dur)
+         , m_max_message_size(o.m_max_message_size)
+         , m_max_http_body_size(o.m_max_http_body_size)
+
+         , m_rng(std::move(o.m_rng))
+         , m_is_server(o.m_is_server)         
+        {}
+
+    #ifdef _WEBSOCKETPP_DEFAULT_DELETE_FUNCTIONS_
+        // no move assignment operator because of const member variables
+        endpoint & operator=(endpoint &&) = delete;
+    #endif // _WEBSOCKETPP_DEFAULT_DELETE_FUNCTIONS_
+
+    #endif // _WEBSOCKETPP_MOVE_SEMANTICS_
+
+
     /// Returns the user agent string that this endpoint will use
     /**
      * Returns the user agent string that this endpoint will use when creating
@@ -165,7 +218,7 @@ class endpoint : public config::transport_type, public
      * @param channels The channel value(s) to set
      */
     void set_access_channels(log::level channels) {
-        m_alog.set_channels(channels);
+        m_alog->set_channels(channels);
     }
 
     /// Clear Access logging channels
@@ -176,7 +229,7 @@ class endpoint : public config::transport_type, public
      * @param channels The channel value(s) to clear
      */
     void clear_access_channels(log::level channels) {
-        m_alog.clear_channels(channels);
+        m_alog->clear_channels(channels);
     }
 
     /// Set Error logging channel
@@ -187,7 +240,7 @@ class endpoint : public config::transport_type, public
      * @param channels The channel value(s) to set
      */
     void set_error_channels(log::level channels) {
-        m_elog.set_channels(channels);
+        m_elog->set_channels(channels);
     }
 
     /// Clear Error logging channels
@@ -198,7 +251,7 @@ class endpoint : public config::transport_type, public
      * @param channels The channel value(s) to clear
      */
     void clear_error_channels(log::level channels) {
-        m_elog.clear_channels(channels);
+        m_elog->clear_channels(channels);
     }
 
     /// Get reference to access logger
@@ -206,7 +259,7 @@ class endpoint : public config::transport_type, public
      * @return A reference to the access logger
      */
     alog_type & get_alog() {
-        return m_alog;
+        return *m_alog;
     }
 
     /// Get reference to error logger
@@ -214,7 +267,7 @@ class endpoint : public config::transport_type, public
      * @return A reference to the error logger
      */
     elog_type & get_elog() {
-        return m_elog;
+        return *m_elog;
     }
 
     /*************************/
@@ -222,52 +275,52 @@ class endpoint : public config::transport_type, public
     /*************************/
 
     void set_open_handler(open_handler h) {
-        m_alog.write(log::alevel::devel,"set_open_handler");
+        m_alog->write(log::alevel::devel,"set_open_handler");
         scoped_lock_type guard(m_mutex);
         m_open_handler = h;
     }
     void set_close_handler(close_handler h) {
-        m_alog.write(log::alevel::devel,"set_close_handler");
+        m_alog->write(log::alevel::devel,"set_close_handler");
         scoped_lock_type guard(m_mutex);
         m_close_handler = h;
     }
     void set_fail_handler(fail_handler h) {
-        m_alog.write(log::alevel::devel,"set_fail_handler");
+        m_alog->write(log::alevel::devel,"set_fail_handler");
         scoped_lock_type guard(m_mutex);
         m_fail_handler = h;
     }
     void set_ping_handler(ping_handler h) {
-        m_alog.write(log::alevel::devel,"set_ping_handler");
+        m_alog->write(log::alevel::devel,"set_ping_handler");
         scoped_lock_type guard(m_mutex);
         m_ping_handler = h;
     }
     void set_pong_handler(pong_handler h) {
-        m_alog.write(log::alevel::devel,"set_pong_handler");
+        m_alog->write(log::alevel::devel,"set_pong_handler");
         scoped_lock_type guard(m_mutex);
         m_pong_handler = h;
     }
     void set_pong_timeout_handler(pong_timeout_handler h) {
-        m_alog.write(log::alevel::devel,"set_pong_timeout_handler");
+        m_alog->write(log::alevel::devel,"set_pong_timeout_handler");
         scoped_lock_type guard(m_mutex);
         m_pong_timeout_handler = h;
     }
     void set_interrupt_handler(interrupt_handler h) {
-        m_alog.write(log::alevel::devel,"set_interrupt_handler");
+        m_alog->write(log::alevel::devel,"set_interrupt_handler");
         scoped_lock_type guard(m_mutex);
         m_interrupt_handler = h;
     }
     void set_http_handler(http_handler h) {
-        m_alog.write(log::alevel::devel,"set_http_handler");
+        m_alog->write(log::alevel::devel,"set_http_handler");
         scoped_lock_type guard(m_mutex);
         m_http_handler = h;
     }
     void set_validate_handler(validate_handler h) {
-        m_alog.write(log::alevel::devel,"set_validate_handler");
+        m_alog->write(log::alevel::devel,"set_validate_handler");
         scoped_lock_type guard(m_mutex);
         m_validate_handler = h;
     }
     void set_message_handler(message_handler h) {
-        m_alog.write(log::alevel::devel,"set_message_handler");
+        m_alog->write(log::alevel::devel,"set_message_handler");
         scoped_lock_type guard(m_mutex);
         m_message_handler = h;
     }
@@ -406,11 +459,11 @@ class endpoint : public config::transport_type, public
      * The default is set by the max_http_body_size value from the template
      * config
      *
-     * @since 0.5.0
+     * @since 0.5.1
      *
      * @param new_value The value to set as the maximum message size.
      */
-    void get_max_http_body_size(size_t new_value) {
+    void set_max_http_body_size(size_t new_value) {
         m_max_http_body_size = new_value;
     }
 
@@ -466,6 +519,35 @@ class endpoint : public config::transport_type, public
     /// Resume reading of new data
     void resume_reading(connection_hdl hdl);
 
+    /// Send deferred HTTP Response
+    /**
+     * Sends an http response to an HTTP connection that was deferred. This will
+     * send a complete response including all headers, status line, and body
+     * text. The connection will be closed afterwards.
+     *
+     * Exception free variant
+     *
+     * @since 0.6.0
+     *
+     * @param hdl The connection to send the response on
+     * @param ec A status code, zero on success, non-zero otherwise
+     */
+    void send_http_response(connection_hdl hdl, lib::error_code & ec);
+        
+    /// Send deferred HTTP Response (exception free)
+    /**
+     * Sends an http response to an HTTP connection that was deferred. This will
+     * send a complete response including all headers, status line, and body
+     * text. The connection will be closed afterwards.
+     *
+     * Exception variant
+     *
+     * @since 0.6.0
+     *
+     * @param hdl The connection to send the response on
+     */
+    void send_http_response(connection_hdl hdl);
+
     /// Create a message and add it to the outgoing send queue (exception free)
     /**
      * Convenience method to send a message given a payload string and an opcode
@@ -559,7 +641,6 @@ class endpoint : public config::transport_type, public
      * @return the connection_ptr. May be NULL if the handle was invalid.
      */
     connection_ptr get_con_from_hdl(connection_hdl hdl, lib::error_code & ec) {
-        scoped_lock_type lock(m_mutex);
         connection_ptr con = lib::static_pointer_cast<connection_type>(
             hdl.lock());
         if (!con) {
@@ -580,8 +661,8 @@ class endpoint : public config::transport_type, public
 protected:
     connection_ptr create_connection();
 
-    alog_type m_alog;
-    elog_type m_elog;
+    lib::shared_ptr<alog_type> m_alog;
+    lib::shared_ptr<elog_type> m_elog;
 private:
     // dynamic settings
     std::string                 m_user_agent;
